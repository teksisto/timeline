* Зачем
** Игры
*** Рифмы
*** Колоды
*** Параллельные тексты

    Примеры параллельных текстов: 

    - запись выступления и презентация
    - песня и ее текст
    - подкаст и трансрипт
    - фильм, аудио дорожки к нему и субтитры
    - цитата на двух языках
    - книга на двух языках
      
    На уровне интерфейса две версии одного документа тоже похожи на
    параллельные тексты, но пока сомнтельно, что и по сути это так.
*** Словарь
**** Личный словарь терминов
**** Словарь иностранных слов

     Автоматический поиск новых слов в тексте. Авто оценка лексической
    сложности текста. Создание заготовок под карточки для запоминания
    с проставленной частью речи и примером использования.

*** Компартментализм
*** События
*** Цитаты

    У цитаты должен быть заголовок и версии на разных языках.

    Из цитат можно строить параллельные цитатники, что возвращает к
    параллельным текстам.

*** Post with input/output
** Задачи инфоорга

   Задачи инфоорга решаются последовательно. Если нет захвата, нечего
   идентифицировать. Если нет идентификации, не к чему привязывать
   классификацию.

   #+BEGIN_QUOTE
   И вот смотрю я на Singly и на предшествующий ему Memolane и до меня
   начинает доходить, что веб-сервисы еще не прошли тот этап, который
   для меня закончился — этап собирания разных данных в одно место. У
   меня были записи в разных форматах, в том числе несколько
   тетрадок. Тетрадки я оцифровал, форматы поубивал, заменив
   текстовыми файлами. Теперь у меня все лежит в одном месте в одном
   формате. Теперь все это можно как-то автоматически обрабатывать. В
   интернете этого еще не произошло, здесь все только начинается.
   #+END_QUOTE

   Каждый слой представляет абстракцию для других слоев.

*** Захват

    Как данные попадают в систему?

    Захват -- это больше про интерфейс

    Keeping is not organizing.

    Захват должен сохранять контекст.

    Захват должен стоить 0. False positive keeping должен умереть. Если
    захват стоит ноль, значит сохранять надо все что почесало мозг. Мы
    не знаем зачем сохраняем.

    Компьютер знает о нас очень много. Все что может быть захвачено
    автоматически должно захватываться автоматически.
      
*** Идентификация

    Как адресовать отдельный элемент в системе?

    Номеров страниц как в книгах больше нет, что делать?

    Идентификация отделяет слой классификации от слоя хранения. После
    того, как элемент добавлен в систему, ему пресваивается UUID и
    классификация осуществлется уже над UUID. Нельзя классифицировать
    прямые пути в файловую систему. Если файл перенести в другое
    место, метаданные, прикрепленные к этому файлу, будут ссылаться на
    пустое место.

    Системе должно быть безразлично не только что именно она
    описывает, но и где оно лежит. Хранение должно быть отделено от
    доступа.

    Есть необходимость идентифицировать не только отдельные документы,
    но и части этих документов.

*** Хранение

    В каком формате хранить информацию из различных источников? 

    Хочется унифицированности.
     
*** Классификация

    Как описывать объекты хранящиеся в системе?

    Онтологии.

    Системе должно быть безразлично не только что именно она
    описывает, но и где оно лежит. Хранение должно быть отделено от
    доступа.
  
    Не все файлы нуждаются в семантике. Целая куча постоянно
    скачивается, просматривается и удаляется. Нет никакого смысла
    наводить на них семантику, кроме может быть примитивной
    машинной. Те файлы, которые должны быть упорядочены, должны лежать
    в семантическом, тщательно структурируемом хранилище. Все
    остальное пускай лежит как раньше.

*** Организация

    В какие структуры объединяются ресурсы?

    Группировка и сортировка.

    Структура информации являются функцией от ее объема. Как только
    меняется объем, структуре приходится его догонять. В одной папке с 7
    файлами легко найти нужный, в одной папке с 1024 файлами уже не очень.

    Кстати, про 1024 файла. Я специально выписал выше, что организация
    включает в себя сортировку. На 1024 файлов можно нормально
    смотреть, если знаешь по какому признаку они отсортированы.

    Сохраненные запросы / Деревья / Контексты

*** Поиск

    Как искать нужную информацию в массиве?

    На больших объемах информации поиск итеративен и разные "мили"
    проходятся разными способами. Полнотекстовый поиск, сохраненные
    запросы и обычный иерархический подход будут мирно сосуществовать
    на машинах.

*** Аннотирование

    Как хранить и связывать аннотации с сохраненными ресурсами?

    Как аннотировать текст?

    Как аннотировать аудио-файлы?

    Как аннотировать видео?

    Аннотирование в самом простом случае -- это комментирование. 

    Удобство аннотирования -- это аргумент в пользу блочной
    идентификации. Можно добавлять комментарии к каждому параграфу.
    
    Аннотирование обновляющегося источника. Обновляющийся источник
    сложно аннотировать. Какие-то части появляются, какие-то
    попадают. Последовательная нумерациия параграфов невозможна, потому
    что она будет ломаться каждую версию. Значит адресовать нужно по
    uuid.
*** Переносимость

    Я готов вбивать руками семантику на весь свой массив данных, но
    только при одном условии: чтобы мне больше никогда не приходилось
    это делать.
* Декомпозиция
** DONE Блог
  
  Представим себе блог, где каждый пост не является монолитом, а
  собирается из кусочков-атомов. Каждый атом имеет уникальный
  идентификатор, хранится отдельно и имеет свой набор
  атрибутов. Каждый параграф, картинка, видео-ролик в посте – это
  атом. Структура поста задается списком из уникальных идентификаторов
  каждого атома, каждый из которых трансклюдится в пост. На каждый
  параграф в посте можно сослаться, навесить атрибуты и добавить
  комментарии.
  
  Структура каждого комментария к посту повторяет его структуру. К
  этому добавляется древовидный или линейный контейнер, который хранит
  порядок комментариев.
  
  Посты организуются в хронологическое дерево. Это может быть
  стандартная схема год/месяц/день или какая-нибудь другая, например,
  год/неделя/день. Деревьев может быть несколько, выбор определяется
  удобством.
  
  Какие элементы структуры имеем в результате?
  
  - атомы с атрибутами 
  - линейный список для объединения атомов в посты
  - комментарии, каждый из которых повторяет структуру поста
  - дерево для комментариев
  - посты организуются в хронологическое дерево
  
  Теперь отрезаем лишние сущности.
  
  Между атомом и постом нет никакой разницы. Оба имеют уникальный
  идентификатор и набор атрибутов. Разница только в том, что у поста
  есть сложный атрибут, который хранит список входящих в него
  атомов. Сущность, обладающую уникальным идентификатором, на которую
  можно навесить атрибуты я дальше буду называть ресурсом.
  
  Между деревом и линейным списком нет никакой разницы, поскольку
  дерево – это просто список списков. Дерево комментариев – это список
  списков, листьями которого являются ресурсы, содержащие комментарии.
  
  Теперь у нас есть два вида ресурсов: посты и комментарии. На самом
  деле, даже больше, потому что атомы тоже различаются – текст,
  картинка, видео. Поскольку у нас есть несколько типов ресурсов,
  логично ввести понятие тип ресурса. Определение ресурса расширяется
  до сущности, у которой есть уникальный идентификатор, атрибуты и
  тип. Тип – это такой же атрибут, как и дата создания, заголовок или
  любая другая мета-информация. Отличает его только то, что он
  является обязательным, поскольку без него мы не будем знать, как
  обрабатывать ресурс. Допустим, мы генерируем на основе нашей
  структуры html. Чтобы отобразить текстовый атом, надо преобразовать
  содержащуюся в нем разметку (например markdown) в html, обернуть это
  в div и отдать браузеру. Чтобы показать картинку, надо обернуть ее в
  тег img и отдать браузеру. Разница в обработке закрепляется в виде
  типа.
  
  Атрибуты — это, строго говоря, тоже ресурсы, а линейные списки
  создаются с помощью цепочек ресурсов, ссылающихся друг на друга. Так
  что кроме ресурсов ничего особо и не остается, но атрибуты и
  линейные списки мы выкидывать пока не будем, а то говорить не о чем
  будет.
  
  Итак, у нас остались:
  
  - ресурсы
  - атрибуты
  - линейные списки
  
  Переводим в термины rdf:
  
  - ресурс по-прежнему остается ресурсом (rdf:Resource)
  - атрибуты в терминологии rdf называются rdf:property 
  - атрибут «тип ресурса» – это rdf:type
  - ресурсы, описывающие атрибуты, имеют rdf:type равным rdf:Property
  
  Схема получается довольно заманчивая, потому что в базе данных все
  поместится в две таблицы: одна для графа и одна для сопоставления
  идентификаторов атомов и все было бы хорошо, если бы речь шла про
  однопользовательскую систему, например, если бы мы говорили про
  гибкую структуру для бекапа различных блогов. Но у блога есть
  комментарии и пользователей много. Нужно разграничение
  доступа. Красивая схема «все в двух таблицах» разваливается. Права —
  зло, про них придется думать отдельно.
  
  Чтобы два раза не вставать, сразу скажу, что в смысле бекапа блог не
  сильно отличается от твиттера, френдфида, фликра и многого
  другого. Все упирается в модель безопастности.
* Предпосылки

  Человеческая память ограничена.

  Нет никакого решения для всех. Поэтому решением является инструмент
  для создания решений.

* Базовые определения
** Ресурс

   Отдельная сущность, адресуемая уникальным идентификатором. Роль
   идентификатора выполняет url. 

   Имеет множество атрибутов в формате ключ=значение. 

   Имеет множество представлений.

   Ресурс имеет класс, который определяет его базовый логический
   тип. Класс определяет какие атрибуты можно вешать на этот ресурс и
   с помощью каких представлений его рисовать.

   Идентификатор позволяет выцепить из источника данных настоящий
   контент, соответствующий ресурсу. Это так называемый dereferencing.

   Контент есть только у неделимых ресурсов, то есть на самом деле не
   у всех. Контент есть у ресурса, являющегося параграфом текста,
   картинкой, аудио-файлом, видео-файлом. Для ресурсов, у которых нет
   контента, устанавливается некий пустой адаптер.

** Представление

   У ресурса есть класс. Классу соответствует множество представлений,
   из которого выбирается нужное. Представление -- это шаблон, который
   получает на входе ресурс, достает из него хеш с атрибутами, с
   помощью адаптера получает контент и рисует из всего этого html.

   У одного ресурса есть множество представлений.

   Три стандартных, которые показывают ресурс вне зависимости от того
   есть у него класс или нет:

   1) ~default~ -- показывает атрибуты и контент. Атрибуты содержащие
      ссылки на другие ресурсы показываются просто ссылками и никак не
      отображаются.
   2) ~inline~ -- показывает только контент. Для параграфа это текст в
      теге ~<p>~, для картинки тег ~<img>~ и так далее.
   2) ~link~ -- показывает только ссылку на ресурс.

   Расширенные, опирающиеся на класс:

   1) ~classed-link~ -- отображает иконку рядом со ссылкой в зависимости
      от типа ресурса.
   2) ~card~ -- показывает некоторую компактную summary по ресурсу и
      ссылку на полную версию. Например для книги это может быть
      обложка, под которой написано полное название и год
      издания. Карточки используются при отображении "плитки" из
      ресурсов.
   3) ~classed-link-with-card~ -- ~classed-link~ у которой при навении
      мышки на ссылку появляется карточка во всплывающем окне.

** Атрибут
   
   Атрибут тоже ресурс. На него тоже можно навешивать атрибуты. 

   Адаптер для него http, потому что так сложилось.

   Формат атрибута ключ=значение. uuid ресурса плюс ключ и значение
   образовывают триплет. Да, я говорю про rdf.

** Адаптер 

   Урл состоит из nid и nss.

   nid -- namespace id. Позволяет выбрать адаптер для совершения с ресурсом базовых
   действий. 

   nss -- namespace spicific string. Позволяет однозначно ссылаться на
   ресурс внутри определенного namespace.
   
   Основные действия, которые должен поддерживать ресурс: 

   - создание
   - чтение
   - редактирование
   - удаление

   Действия над метаданными внутри ресурса:

   - добавить единицу метаданных в формате ключ=значение
   - вернуть значение по определенному ключу
   - считать все метаданные и вернуть хеш
   - установить значение по определенному ключу
   - удалить единицу метаданных по ключу

   Некоторые ресурсы могут не поддерживать метаданные (plain text) или
   быть недоступными для удаления/редактирование (страница в
   интернете). В этом случае адаптер просто не поддерживает эти
   операции.

** DONE Контекст

   Атрибуты:

   - название
   - заголовочный блок
   - запрос, определяющий хвост
   - хвост = массив ресурсов

   Контекст -- это легковестный блог с постом в заголовке. 

   Контекст по природе гетерогенен. Он может захватывать ссылки,
   картинки, посты, ресурсы любого типа. 

   Контекст нужен для объединения ресурсов в одно целое и показывает
   хронологию развития какой-то темы. 

   + Он предназначен либо для мелкого собирательства, которое возможно
     перестет во что-то большее (например в заметку). Тогда заметка
     должна стать хедом. 

   + Либо для подборки однотипных высказываний (рифмы) Хотя их можно
     делать и коммуникативными связями.

   + Крупномаштабный харвест всего встреченного на пути по интересной теме.

*** Заголовочный блок 

    Заголовочный блок может использоваться как summary или описание
    того, зачем контекст нужен.

    Так же его можно использовать для выведения диаграмм. Например
    контекст в который входят все поступления/расходы за месяц может
    показывать в заголовке как менялась сумма денег в кошельке.

    Если контекст используется для создания категории постов, то есть
    как тег, то он дает некоторые преимущества. Маркер контекста может
    быть любым (хоть uuid). В то время как отображаться будет
    нормальное название. В головном блоке можно писать что здесь лежит
    и зачем.

*** Форма быстрого поста

   В контексте есть форма быстрого поста. Ты пишешь туда текст, а он
   сам разбирается какие атрибуты ему проставить. Интересный вопрос:
   как и чем из запроса можно выводить атрибуты, которые присущи новым
   записям.

*** Запрос

    Некоторые базовые операции:

    - атрибут равен
    - атрибут не равен
    - атрибут больше/меньше
    - логическое и
    - логическое или

*** Хвост

   Хвост определяется запросом.

   Контекст может захватывать ресурсы автоматически, если ему задать
   правила. Все заметки, которые ссылаются на конкретного
   человека. Все покупки. 

   Контекст умеет показывать хвост в прямом и обратном хронологическом
   порядках. Обратный хронологический порядок важен. Представьте себе
   насколько меня достало отсутствие такой простой вещи в интернете,
   если мне хочется написать про это отдельно. 

*** Контекст есть у каждого ресурса

    Еще одно странное следствие, это то, что контекст есть у каждого
    ресурса. То есть есть как минимум какой-то контекст по-умолчанию в
    который входят:

    - все ресурсы, которые ссылаются на данный
    - все ресурсы на которые ссылается он сам. 

    В первом случае из множества триплетов, у которых на месте объекта
    стоит данный ресурс, выбираются уникальные значения из столбца
    субъектов.

*** Контекст как строительный блок интерфейса

    Получается, что контекст -- это один из основных строительных
    блоков интерфейса. Потому что любые колекции (eg список
    полученных/отправленных писем для человека) -- это фильтр, который
    вытаскивает сущности из базы и показывает в хедере статистику.

*** Динамическое дерево как вложенные контексты

    Интересно, что дерево вложенных контекстов -- это и есть то самое
    динамическое дерево про которое я еще не говорил.

    Новые сущности просеиваются сначала сквозь фильтр первого
    контекста, потом через фильтры вложенных контекстов и где-то
    оседают. Механизм просеивания -- это детали реализации.
 
    Еще раз. Контекст гетерогенен. Ему без разницы что засасывать,
    потому что засасывает он ресурсы, адресуемые uuid. Поэтому ничто
    не мешает ему содержать в себе другие контексты.
 
    В этом случае, кстати, голова контекста является элементом,
    отображаеммым в ленте контекста верхнего уровня. Не надо так же
    забывать, что голова контекста -- это обычный ресурс и у него, как
    и у любого друго ресурса могут быть разные вьюшки для
    отображения. Что позволяет например ужать в графическом
    представлении весь контекст до заголовка со ссылкой.
*** Вопросы

    << Чем отличается лента от структурированного документа? >>

    Ничем.

    << Чем отличаются лента/дерево/контекст друг от друга? Интерфейсом? >>

    Ничем не отличаются. Да, интерфейсом.

* Подходы
** Наивный реляционный подход

   Объекты каждого класса хранятся в отдельной таблице, связи между
   ними во внешних ключах. Связи лежат в коде. Новый класс -- новый
   скаффолд. Ограничения разползаются в валидации и колбеки.

** Реляционный подход
   
   Все хранится в трех таблицах: Resources, Properties, Trees.

   Trees -- это оптимизация, которая позволяет хранить деревья,
   упорядоченные и не упорядоченные списки, не прибегая к упоротому
   способу ~rdf:next~. 

   В таблице Resources включен single-table inheritance, который
   выгружает ресурсы в соответствующие ruby-классы.    

   Валидации делаются засчет того, что у ресурсов типа Property в
   классах есть методы в духе ~domain~ и range, которые возвращают
   множества того, что можно крепить к свойству слева и справа
   соответственно.

   Инферинг делается в духе:

   : after_create :add_inverse_property

   У классов нет множественного наследования. Мне оно строго говоря и
   не нужно, но реализовывать проще, если принять это
   ограничение. Правда придется разуруливать два триплета с которых
   вообще начинается вся семантика. Потом все нормально.

*** Конспект

    Сначала у нас есть один ресурс -- книга. У него есть атрибут content
    в котором лежит ссылка на дерево.
    
    Ссылка на дерево -- это указатель на анонимный корневой элемент
    дерева, к которому крепятся его элементы. У элемента дерева, помимо
    информации о вложенности есть только одна полезная нагрузка --
    ссылка на ресурс.

    Мы делаем первый запрос и получаем из ресурса класса ~Book~ ресурс
    класса ~Outline~.

    Мы делаем второй запрос и получаем свойство ~content~ ресурса класса
    ~Outline~. В нем хранится ссылка на дерево. 

    Мы делаем третий запрос и получаем упорядоченный массив
    элементов дерева, потому что nested set. Ресурсы крепятся к
    элементам дерева с помощью ~includes~. Для этого нужен один ~join~.
    На выходе получаем массив элементов дерева, с уже загруженными из
    базы элементами типа ~Paragraph~, ~Section~ или ~List~.

*** Цитаты, разложенные по главам

    У цитаты есть функциональное свойство источник. Функциональное в
    том смысле, что оно у него может быть только одно, потому что у
    цитаты есть только один источник.

    Цитата крепится свойством ~источник~ к элементу оглавления класса
    ~Section~. Оглавление в книге одно на всех. К нему крепятся и
    конспекты, и цитаты, и контент. Это означает, что элемент
    оглавления должен иметь свой тип и свои свойства, к которым
    крепятся соответствующие деревья.

    Допустим он имеет тип ~Section~. У ~Section~ есть четыре атрибута:
    ~dc:title~, ~my:content~, ~my:outlite~, ~my:quotes~.

    Первый запрос: взять у книги атрибут ~оглавление~ и достать оттуда
    ссылку на анонимный элемент дерева, который хранит все элементы
    оглавления класса ~Section~.

    : resource[toc] = tree_id 

    Второй запрос: прийти в таблицу деревья и вытащить оттуда всех
    детей этого анонимного элемента, сделав на них ~inludes~, что дает
    нам все ресурсы описывающие главы. Это первый ~join~.

    : tocs = Tree.find(tree_id).descendants.includes(r)

    Третий запрос: из каждого ресурса типа ~Section~ надо достать
    свойство ~quotes~, которое ссылается на анонимный элемент дерева,
    который хранит список элементов класса ~Quote~, который нам и нужен.

** Семантика
*** Прямая

    Триплстор, нормальный ризонер, запросы на ~sparq~. Интерфейс на
    рельсах. Моделей нет. Контроллер по сути один --
    ~ResourcesController~. В основном надо рисовать партиалы для
    отрисовки ресурсов конретного класса с указанной детализаций и
    связанными ресурсами.

*** Наведенная

    На сервере стоит вордпресс, редмайн и медиавики. Делается точка
    доступа ~sparq~, которая маппит их таблицы в rdf и предоставляет
    унифицированный доступ. На основе этой точки доступа рисуется
    интерфейс, как в прямом подходе.

    Не знаю насклько это возможно, но везде отдельно пишут, что на
    обычные реляционные таблицы можно навести семантику.

* Case study
** Org-mode
** Calibre

   reference-mode в читалке
** MusicBrainz
** Ginko

   Очень хороший. Умеет делать презентации и возвращать текст в виде json.

   https://gingkoapp.com
** TiddlyWiki

   http://tiddlywiki.com/
** Purple
** Smallest Federated Wiki
** Scrivener
   
   http://www.literatureandlatte.com/scrivener.html

** Tinderbox

   https://en.wikipedia.org/wiki/Tinderbox_%28application_software%29
** Del.icio.us
*** Про отношения с делишесом
    
    Плохие у меня с делишесом отношения. Естественный подход мне не
    нравится. Точнее он у меня изначально вызвал какое-то
    непонимание. Поэтому изначально я пользовался противоестественным
    способом. Пытался добавлять избытычные метаданные. Сделал подобие
    онтологии. Но проблема этого подхода в том, что дальше с данными
    сделать ничего нельзя. Язык запросов лучше даже на френдфиде.
    
    Есть другая сторона. Почему фрф лучше для показывания
    ссылок. Сохранение ссылки очень мало кто сопровождает тем почему
    эта ссылка привлекла внимание. Никто не пишет эту самую
    пресловутую тысячу знаков. Это долго и никому не
    инетересно. Сохранение ссылки – это тоже самое рассказывание
    истории. Потому что без истории ссылки никому не нужна. Этих
    ссылок вокруг слишком много, чтобы во все тыкать и самому
    разбираться что там к чему. Социальность делишеса проявляется
    только в одном случае – когда люди начинают искать популярные
    ссылки по какому-то тегу.
    
    Компенсировать отсутствие обсуждения заправлением делишеса во
    френдфид тоже плохо. Потому что если исходить из того, что это все
    ссылки "на потом", то соотношение сигнал/шум становится слишком
    низким. Каждый сохраняет в день по несколько ссылок умножить на
    количество френдов – получается жуткий мусор. Поэтому ссылки нужно
    обсуждать там, где они лежат.
    
    Одно время я очень перся от делишеса, но сейчас это прошло. Тогда
    мне хотелось, чтобы так можно было работать с файлами на харде. Но
    если из метаданных нельзя ничего выжать, то на фиг они нужны?
    
    У делишеса есть проблема интерфейса – сохранять слишком долго. В
    результате на смену ему пришел Read It Later. Пост сохраняется
    одним нажатием галочки. Получается обычный линейный список. То,
    что прошло испытание временем переносится в делишес. Или про это
    рассказывается история во френфиде. Лишнее удаляется одним
    кликом. То что там нет тегов – это отдельная тема. Мне кажется,
    что ключевые слова можно вытаскивать из текста
    автоматом. Используя API того же делишеса или гугла. Или тупо
    смотреть по частоте.
    
    Получается, что делишес – это медленные коммуникации. Медленные
    именно из-за интерфейса, а не по сути. Из этого вытекает очевидное
    в принципе заключение, что пропускная способность интерфейса
    определяет суть сервиса. Если сделать медленный интерфейс для
    чата, то это будет уже форум. Условно говоря. Если сделать быстрый
    интерфейс для форума, то получится френдфид. Опять же очень
    условно.
** Gifford - Semantic file systems

  Подход, описанный Гиффордом, можно наглядно продемонстрировать на
  примере делишеса. Факт того, что он писал это еще в 1991 году, убивает на
  фиг. Но. Главный недостаток этого подхода заключается в том, что когда
  множества полей (fields) и их значений (values) выростет, системой
  будет невозможно пользоваться. Это видно и на примере делишеса. Никто
  не пользуется инкрементным поиском. Это прикольно, но медленно и нафиг
  никому не сдалось. Проблема инкрементного поиска в том, что вылезает
  слишком много не нужных параметров поиска.

  Сохраненные запросы имеют то преимущество перед подходом Гиффорда, что
  они заранее отсеивают ненужные параметры поиска. Дело не в том, что
  дерево -- это плохо. Дело в том, что одно дерево это плохо. Деревьев
  должно быть много. В файловую систему из можно интегрировать с помощью
  виртуальных файловых систем.

** NEPOMUK (framework)

   https://en.wikipedia.org/wiki/NEPOMUK_%28framework%29

** Chandler

   https://en.wikipedia.org/wiki/Chandler_%28software%29
** vk.com/audio
** Fluidinfo

   http://fluidinfo.com
** Friendfeed							       :dead:
** Locker 							       :dead:

   Проект умер.

** Singly							       :dead:
   
   Наткнулся тут на сервис Singly. Это еще один метасервис по
   собиранию данных из разных веб-сервисов в единую ленту. Singly
   ориентирован не только на собирание, но и на предоставление к
   собранному API для различных манипуляций и визуализации.

   Singly was founded by Jeremie Miller, creator of XMPP, Jason Cavnar
   and Simon Murtha-Smith. Matt Zimmerman, former CTO of Ubuntu,
   joined Singly and was the CTO.

   2013-08-22 -- поглощен компанией [[http://appcelerator.com/][appcelerator]].

* Частные задачи
** Дневник в текстовых файлах

   На входе есть текстовые файлы. Из метаданных есть только дата
   создания, содержащаяся в названии, и дата последнего изменения,
   записанная в файловой системе.

   На выходе хочется получить тексты разбитые на блоки с
   идентификаторами и заготовку под вбивание метаданных.

   Похоже единственным вменяемым решением будет допилить тексты до
   состояния, когда маркдаун будет свободно рендерить их в html, после
   чего скриптом проставлять идешники для все блочных
   элементов. Метаданные хранить в теге meta.

   Необходимые атрибуты для текстовых файлов:

   - описываемая дата
   - дата создания
   - изначальная медиа
   - дата оцифровки
   - эпоха
   - заголовок
   - местонахождение

* Инструменты
** Ruby
*** TODO rdf
*** qt
*** fuse
*** NLP

    [[https://github.com/louismullie/treat][treat]] -- natural language processing framework for Ruby. 

** Триплсторы
*** AllegroGraph

    http://franz.com/

    Выглядит вполне живым. Копирайт на сайте обновляется, есть всякие
    видео и список событий.

    Есть community версия и платная.

    Внезапно есть биндинги для Common Lisp и курсы по изучению Common Lisp.
*** Neo4j

    Нашел старый листочек, на котором написано "Neo4j?".

    Книга O'Reilly "Graph Databases" -- это введение в neo4j.

    http://graphdatabases.com

** WebDAW
** Parallel text
  
   [[http://www.abbyy.com/aligner/][Abbyy Aligner]]

   [[http://www.supernova-soft.com/wpsite/products/text-aligner/create-parallel-text-for-language-lerning/][Supernova Aligner]]

** JavaScript
*** Текствовые редакторы
**** Prose mirror
     http://prosemirror.net/
**** Substance
     http://substance.io/
*** Everything else
**** blast

     Blast.js separates text in order to facilitate typographic
     manipulation. It has four delimiters built in: character, word,
     sentence, and element. Alternatively, Blast can match custom
     regular expressions and phrases.

     http://julian.com/research/blast/

**** datatables

     http://datatables.net/

**** grid

     https://github.com/ubervu/grid

     https://github.com/ducksboard/gridster.js

**** countdown

     http://hilios.github.io/jQuery.countdown/examples/multiple-instances.html

* Книги
** Graph Databases						    :oreilly:
* Ссылки

   http://infotoday.com/ -- новости

   http://booksblog.infotoday.com/ -- книги

** Подборки
*** Иван Бегтин -- Курсы и лекции по работе с данными

    http://ivan.begtin.name/2013/01/08/lectures/

*** urbansheep
**** Полоски
     - [[http://utx.ambience.ru/users/urbansheep/info_organization][info organization]]
     - [[http://utx.ambience.ru/users/urbansheep/classification][classification]]
     - [[http://utx.ambience.ru/users/urbansheep/memory_management][memory management]]
     - [[http://utx.ambience.ru/users/urbansheep/knowledge_management][knowledge management]]
     - [[http://utx.ambience.ru/users/urbansheep/hypertext][hypertext]]
**** (Friend|free)feed

     Старые ссылки на френдфид, когда фрифид поднимет бекапы, можно будет поменять на фрифид.

     - [[http://friendfeed.com/search?q=%23%D0%B8%D0%BD%D1%84%D0%BE%D0%BE%D1%80%D0%B3+from%3Aurbansheep][инфоорг]]
     - [[http://friendfeed.com/search?q=%23%D1%81%D0%B2%D0%BE%D0%B9_%D0%BD%D0%B5%D0%B1%D0%BE%D0%BB%D1%8C%D1%88%D0%BE%D0%B9_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D0%BD%D0%B5%D1%82][свой небольшой интернет]]
     - [[http://friendfeed.com/search?q=%23%D1%86%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%B0%D1%8F_%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F][цифровая история]]
     - [[http://friendfeed.com/search?q=%23%D0%B0%D1%80%D1%85%D0%B8%D0%B2%D0%B8%D1%81%D1%82%D1%8B][архивисты]]
* Пользовательская онтология
** Атрибут

   Классы:

   - Property

   Атрибуты:

   - subPropertyOf
   - domain
   - range

   Онтологии:

   - rdf

** Параграф

   Классы:

   - Paragraph

   Атрибуты:

   - разметка
   - упоминания/ссылки
   - автор
   - язык
   - ссылка на параллельные параграфы

** Книга
   
   Классы:

   - Book
   - BookEdition
   - BookTranslation

   Атрибуты:
   
   - название
   - авторы = массив людей
   - год издания
   - издательство
   - язык
   - обложка
   - серия
   - файл
   - номер издания
   - оглавление
   - когда читал = массив временных отрезков
   - количество прочтений

   Одна сущность для изданий разных годов и переводов на разные языки,
   к которой крепятся издания и переводы. Название -- хеш, где ключи -
   это локали, а значения -- название на этих локалях.

   Авторы -- это массив, а не строка. Каждый автор -- ссылка на
   человека. 

   К оглавлению крепятся главы, цитаты, слова и конспекты. К каждому
   параграфу можно прицепить комментарии.

   Импорт epub поблочно.

*** Оценка количества триплетов при импорте книги

    Книжка "Learning SPARQL - Bob DuCharme". 

    Поиск блочных элементов:

    : cat OEBPS/*html > all
    : grep -cP '<img|<ol|<li[>\s]|<ul[>\s]|<p[>\s]|<pre[>\s]|<h\d[>\s]|<dd|<dt|<table|<tr|<td' all
    : => 2363 <1>

    Количество заголовков в оглавлении:

    : grep -cP '<a' bk01-toc.html
    : => 268

    Получается в среднем около 8 блочных элементов на элемент
    заголовка. Предположим, что большинство элементов прикреплены к
    заголовкам третьего уровня. (Уровень заголовка считается от единицы.)
    
    hasPart / isPartOf. Формула: ~2 * n * (d + 1)~ Каждый блочный элемент
    принадлежит своему заголовку и всем его родительским.

    : 2 * 2363 * (3 + 1) = 18904 <2> 

    Теперь у нас есть количество элементов и есть связи. Надо какие-то
    индексы, чтобы сортировать части внутри заголовка. Придется
    использовать упоротую систему нумерации из rdf, где для описания
    связи двух элементов нужно три триплета.

    : (2363-1) * 3 = 7086 <3>

    С учетом того, что информация про язык, авторов и так далее не
    подвергается инференсингу, то в сумме получается:

    : 2363 + 18904 + 7086 = 28353

    30k триплетов на одну книгу. На 1k книг -- 30 000 000 триплетов.

** Фильм

   Классы: 

   - Movie

   Атрибуты:

   - название
   - год выхода
   - обложка
   - режиссер
   - сценарист
   - игровой/анимация
   - актеры = массив людей
   - скриншоты = массив картинок
   - саундрек = ссылка на музыкальный альбом
   - файл
   - когда посмотрел = массив временных отметок
   - комментарии

** Сериал

   Классы:

   - TvSeries
   - TvSeriesSeason
   - TvSeriesEpisod

   Атрибуты:

   - название
   - сезоны = массив сезонов
   - канал
   - год
   - комментарии

*** Сезон 

    Атрибуты:

    - эпизоды = упорядоченный набор эпизодов
    - комментарии

*** Эпизод

    - air date
    - название
    - когда посмотрел = массив временных отметок
    - скриншоты = массив картинок
** Человек

   Классы:

   - Person
   - Author
   - Contributor

   Атрибуты:

   - дата рождения
   - контакты/телефоны
   - фотография
   - описание

   Контекст:

   - ссылки на упоминия этого человека
   - фотографии с этим человеком
   - аудио-записи с этим человеком
   - видео-записи с этим человеком
   - письма ему или от него
   - везде где автор
   - везде где контрибутор

   Онтологии: foaf

   Актеры -- отдельный класс. Писатели -- отдельный класс. Для них
   существуют какие-то подсвойства dc:author или dc:contributor.

** Организация

   Классы:

   - Organization

   Атрибуты:

   - название
   - люди = массив человеков
   - логотип = ссылка на картинку
   - адрес

   Онтологии: foaf

** Временной отрезок
*** День

    - дата
    - все заметки
    - местонахождение
    - поступления денег
    - покупки
    - вся почта
    - все чаты
    - история браузера
    - события
    - блоки опросников
    - коммиты
    - посты в сервисах
    - музыка с ластфм
    - температура за окном
    - время прихода на работу
    - посмотренные фильмы/сериалы
    - прочитанные книги
    - настроение / полоски урбаншипа

*** Неделя
    - номер
    - подведение итогов по деньгам
    - топ-композиций
    - всякая агрегация

*** Месяц

    - всякая аггрегация

*** Год

    - всякая агрегация
    - прочитано книг
    - просмотрено фильмов
    - потрачено денег
    - заработано денег
    - важные события = массив событий

** Событие

   - название
   - дата
   - адрес
   - организация
   - денежный перевод
   - связанные люди = массив человеков
   - описание
 
** Пост
*** Текстовая заметка
*** Аудио
*** Видео
*** Фотография
** Цитата
*** Версии на разных языках
** Картинка
*** Скриншот
*** Фотография
*** Иллюстрация
*** Обложка альбома
*** Обложка фильма
** Набор картинок
** Аудио
** Музыкальный альбом
*** Обложка
*** Набор треков
** Слово
*** Словарь иностранных слов
*** Объяснение термина
** Текст
* Устоявшиеся термины
  - [[https://en.wikipedia.org/wiki/Semantic_desktop][Semantic desktop]]
  - [[https://en.wikipedia.org/wiki/Personal_knowledge_base][Personal knowledge base]]
  - [[https://en.wikipedia.org/wiki/Parallel_text][Parallel text]]
  - [[https://en.wikipedia.org/wiki/Transclusion][Transclusion]]

* Ассоциации
** Association for Information Science and Technology

   Ааа, ыыы, много всего, оно живое. 

   https://www.asist.org/
* Конференции
** Personal Digital Archiving Conference

   Видео лежат на archive.org.

   http://personaldigitalarchiving.com
   
   https://archive.org/details/PDA2015

* Учебные заведения
** UC Berkeley School of Information
* Стандарты
** ISO
*** ISO 9
    Транслитерация кирилицы в латинские символы.

*** ISO 639
    Коды языков.

*** ISO 2108
    ISBN

*** ISO 3166
    Коды названий стран.

*** ISO 4217
    Коды валют.

*** ISO 8601
    Дата и время.

** RFC
*** RFC 3986
    Определение URI.

* Зачем бить на блочные элементы

  Удобство идентификации -- можно давать ссылку на конкретное место в
  тексте. Например цитаты -- как пример производного ресурса -- могут
  ссылаться на конкретное место, одкуда они были взяты. Возможность
  поставить ссылку на что угодно, начиная от параграфа и элемента
  списка до конкретной ячейки таблицы.

  Удобство классификации -- можно навешивать атрибуты на что угодно. 

  Удобство аннотирования -- к каждому параграфу можно добавить
  аннотацию, например комментарий.

  Разбивка на параграфы позволяет строить параллельные тексты. Если
  параллелить две книги выглядит как сложная задача, то запараллелить
  несколько переводов стихотворения или две цитаты -- это вполне
  посильная задача даже для выполнения руками.
