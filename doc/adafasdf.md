<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Предпосылки</a></li>
<li><a href="#sec-2">2. Задачи инфоорга</a>
<ul>
<li><a href="#sec-2-1">2.1. Захват</a></li>
<li><a href="#sec-2-2">2.2. Идентификация</a></li>
<li><a href="#sec-2-3">2.3. Хранение</a></li>
<li><a href="#sec-2-4">2.4. Классификация</a></li>
<li><a href="#sec-2-5">2.5. Структурирование</a></li>
<li><a href="#sec-2-6">2.6. Поиск</a></li>
<li><a href="#sec-2-7">2.7. Репрезентация</a></li>
<li><a href="#sec-2-8">2.8. Аннотирование</a></li>
<li><a href="#sec-2-9">2.9. Переносимость</a></li>
</ul>
</li>
<li><a href="#sec-3">3. Чего мне хочется от информационного менеджера</a>
<ul>
<li><a href="#sec-3-1">3.1. Объединение базы данных и файлового менеджера</a></li>
<li><a href="#sec-3-2">3.2. Блочный текстовый редактор</a>
<ul>
<li><a href="#sec-3-2-1">3.2.1. Зачем бить на блочные элементы</a></li>
</ul>
</li>
<li><a href="#sec-3-3">3.3. Динамические деревья</a>
<ul>
<li><a href="#sec-3-3-1">3.3.1. Проблемы иерархических файловых систем</a></li>
<li><a href="#sec-3-3-2">3.3.2. Замена одного дерево на множество</a></li>
<li><a href="#sec-3-3-3">3.3.3. Сохранение файловой семантики</a></li>
</ul>
</li>
<li><a href="#sec-3-4">3.4. Контекст</a>
<ul>
<li><a href="#sec-3-4-1">3.4.1. Заголовочный блок</a></li>
<li><a href="#sec-3-4-2">3.4.2. Форма быстрого поста</a></li>
<li><a href="#sec-3-4-3">3.4.3. Хвост</a></li>
<li><a href="#sec-3-4-4">3.4.4. Контекст есть у каждого ресурса</a></li>
<li><a href="#sec-3-4-5">3.4.5. Контекст как строительный блок интерфейса</a></li>
<li><a href="#sec-3-4-6">3.4.6. Динамическое дерево как вложенные контексты</a></li>
</ul>
</li>
<li><a href="#sec-3-5">3.5. Параллельные тексты</a></li>
</ul>
</li>
<li><a href="#sec-4">4. Что бы я со всем этим делал</a>
<ul>
<li><a href="#sec-4-1">4.1. Оглавления для источников</a></li>
<li><a href="#sec-4-2">4.2. Конспекты</a></li>
<li><a href="#sec-4-3">4.3. Цитатник</a>
<ul>
<li><a href="#sec-4-3-1">4.3.1. Привязка цитат к оглавлению книги</a></li>
<li><a href="#sec-4-3-2">4.3.2. Заголовки для цитат</a></li>
<li><a href="#sec-4-3-3">4.3.3. Форматирование внутри цитат</a></li>
<li><a href="#sec-4-3-4">4.3.4. Параллельные цитатники</a></li>
<li><a href="#sec-4-3-5">4.3.5. Колоды</a></li>
<li><a href="#sec-4-3-6">4.3.6. Рифмы</a></li>
<li><a href="#sec-4-3-7">4.3.7. Компартментализм</a></li>
</ul>
</li>
<li><a href="#sec-4-4">4.4. События</a></li>
<li><a href="#sec-4-5">4.5. Словарь</a>
<ul>
<li><a href="#sec-4-5-1">4.5.1. Личный словарь терминов</a></li>
<li><a href="#sec-4-5-2">4.5.2. Словарь иностранных слов</a></li>
</ul>
</li>
<li><a href="#sec-4-6">4.6. Импорт данных из веб-сервисов</a></li>
</ul>
</li>
<li><a href="#sec-5">5. Поиск подхода к реализации</a>
<ul>
<li><a href="#sec-5-1">5.1. Декомпозиция</a>
<ul>
<li><a href="#sec-5-1-1">5.1.1. Блог</a></li>
<li><a href="#sec-5-1-2">5.1.2. Оценка количества триплетов при импорте книги</a></li>
</ul>
</li>
<li><a href="#sec-5-2">5.2. Базовые определения</a>
<ul>
<li><a href="#sec-5-2-1">5.2.1. Ресурс</a></li>
<li><a href="#sec-5-2-2">5.2.2. Представление</a></li>
<li><a href="#sec-5-2-3">5.2.3. Атрибут</a></li>
<li><a href="#sec-5-2-4">5.2.4. Адаптер</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-6">6. Как это все может выглядеть на практике</a>
<ul>
<li><a href="#sec-6-1">6.1. Реляционный подход</a>
<ul>
<li><a href="#sec-6-1-1">6.1.1. Конспект</a></li>
<li><a href="#sec-6-1-2">6.1.2. Цитаты, разложенные по главам</a></li>
</ul>
</li>
<li><a href="#sec-6-2">6.2. Обычный реляционный подход + наведенная семантика</a></li>
<li><a href="#sec-6-3">6.3. Семантика</a>
<ul>
<li><a href="#sec-6-3-1">6.3.1. OpenLink Virtuoso</a></li>
<li><a href="#sec-6-3-2">6.3.2. Stardog</a></li>
<li><a href="#sec-6-3-3">6.3.3. AllegroGraph</a></li>
</ul>
</li>
<li><a href="#sec-6-4">6.4. Графовая база данных</a></li>
</ul>
</li>
<li><a href="#sec-7">7. История</a>
<ul>
<li><a href="#sec-7-1">7.1. (1945) Vannevar Bush — As We May Think</a></li>
<li><a href="#sec-7-2">7.2. (1967) Andries van Dam, Ted Nelson — Hypertext Editing System</a></li>
<li><a href="#sec-7-3">7.3. (1968) Douglas Engelbart — oN-Line System</a></li>
<li><a href="#sec-7-4">7.4. (1968) Andries van Dam — File Retrieval and Editing System</a></li>
<li><a href="#sec-7-5">7.5. (1985) Intermedia</a></li>
<li><a href="#sec-7-6">7.6. (1991) Gifford — Semantic file systems</a></li>
<li><a href="#sec-7-7">7.7. (1993) LDAP</a></li>
<li><a href="#sec-7-8">7.8. (1996) Eric Freeman and David Gelertner — Lifestreams</a></li>
<li><a href="#sec-7-9">7.9. (1999) Presto</a></li>
<li><a href="#sec-7-10">7.10. (2000) id3v2.4</a></li>
<li><a href="#sec-7-11">7.11. (2000) MusicBrainz</a></li>
<li><a href="#sec-7-12">7.12. (2001) Eric Kim — Purple</a></li>
<li><a href="#sec-7-13">7.13. (2001) Tim Berners-Lee — Semantic Web</a></li>
<li><a href="#sec-7-14">7.14. (2001) Tinderbox</a></li>
<li><a href="#sec-7-15">7.15. (2003) Joshua Schachter — Del.icio.us</a></li>
<li><a href="#sec-7-16">7.16. (2003) Org-mode</a></li>
<li><a href="#sec-7-17">7.17. (2004) W3C — RDF / RDFS / OWL</a></li>
<li><a href="#sec-7-18">7.18. (2007) DBpedia</a></li>
<li><a href="#sec-7-19">7.19. (2007) Scrivener</a></li>
<li><a href="#sec-7-20">7.20. (2008) Evernote</a></li>
<li><a href="#sec-7-21">7.21. (2009) Fluidinfo</a></li>
<li><a href="#sec-7-22">7.22. (2013) Ginko</a></li>
<li><a href="#sec-7-23">7.23. Calibre</a></li>
<li><a href="#sec-7-24">7.24. Smallest Federated Wiki</a></li>
<li><a href="#sec-7-25">7.25. Chandler</a></li>
<li><a href="#sec-7-26">7.26. CommonTag</a></li>
<li><a href="#sec-7-27">7.27. Friendfeed</a></li>
<li><a href="#sec-7-28">7.28. Locker</a></li>
<li><a href="#sec-7-29">7.29. Singly</a></li>
<li><a href="#sec-7-30">7.30. NEPOMUK</a></li>
<li><a href="#sec-7-31">7.31. TiddlyWiki</a></li>
</ul>
</li>
<li><a href="#sec-8">8. Ссылки</a>
<ul>
<li><a href="#sec-8-1">8.1. Учебные заведения</a></li>
<li><a href="#sec-8-2">8.2. Термины</a></li>
<li><a href="#sec-8-3">8.3. Люди</a></li>
<li><a href="#sec-8-4">8.4. Книги</a></li>
<li><a href="#sec-8-5">8.5. Ассоциации</a></li>
<li><a href="#sec-8-6">8.6. urbansheep</a>
<ul>
<li><a href="#sec-8-6-1">8.6.1. Pinboard</a></li>
<li><a href="#sec-8-6-2">8.6.2. FriendFeed</a></li>
<li><a href="#sec-8-6-3">8.6.3. LiveJournal</a></li>
</ul>
</li>
<li><a href="#sec-8-7">8.7. Конференции</a></li>
</ul>
</li>
</ul>
</div>
</div>

![img](../images/pepe_silvia.png)

# Предпосылки<a id="sec-1" name="sec-1"></a>

Человеческая память ограничена. Поэтому нужен инструмент который
помогает забывать лишнее, вспоминать нужное и наводить порядок в
голове.

Нет никакого решения для всех. Поэтому решением является инструмент
для создания решений.

# Задачи инфоорга<a id="sec-2" name="sec-2"></a>

Сначала я выпишу задачи, которые решает любая система по хранению
данных, чтобы потом можно было ссылаться на эти термины.

Задачи инфоорга решаются последовательно. Если нет захвата, нечего
идентифицировать. Если нет идентификации, не к чему привязывать
классификацию.

Каждый слой представляет абстракцию для других слоев.

> И вот смотрю я на Singly и на предшествующий ему Memolane и до меня
> начинает доходить, что веб-сервисы еще не прошли тот этап, который
> для меня закончился — этап собирания разных данных в одно место. У
> меня были записи в разных форматах, в том числе несколько
> тетрадок. Тетрадки я оцифровал, форматы поубивал, заменив
> текстовыми файлами. Теперь у меня все лежит в одном месте в одном
> формате. Теперь все это можно как-то автоматически обрабатывать. В
> интернете этого еще не произошло, здесь все только начинается.

## Захват<a id="sec-2-1" name="sec-2-1"></a>

Как данные попадают в систему?

Захват &#x2013; это больше про интерфейс.

Keeping is not organizing.

Захват должен сохранять контекст.

Захват должен стоить 0. False positive keeping должен умереть. Если
захват стоит ноль, значит сохранять надо все что почесало мозг. Мы
не знаем зачем сохраняем.

Компьютер знает о нас очень много. Все что может быть захвачено
автоматически должно захватываться автоматически.

## Идентификация<a id="sec-2-2" name="sec-2-2"></a>

Как адресовать отдельный элемент в системе?

Номеров страниц как в книгах больше нет, что делать?

Идентификация отделяет слой классификации от слоя хранения. После
того, как элемент добавлен в систему, ему пресваивается UUID и
классификация осуществлется уже над UUID. Нельзя классифицировать
прямые пути в файловую систему. Если файл перенести в другое
место, метаданные, прикрепленные к этому файлу, будут ссылаться на
пустое место.

Системе должно быть безразлично не только что именно она
описывает, но и где оно лежит. Хранение должно быть отделено от
доступа.

Есть необходимость идентифицировать не только отдельные документы,
но и части этих документов.

## Хранение<a id="sec-2-3" name="sec-2-3"></a>

В каком формате хранить информацию из различных источников?

Хочется унифицированности при которой не будет теряться информация.
Например при переносе заметок из livejournal в wordpress может
потеряться информация о текущей прослушиваемой музыке, которая есть
в постах livejournal. Эта информация ничем особо не отличается ото
всей остальной &#x2013; просто метаданные для поста. Тем не менее она
тереется, поскольку в целевой системе нет такого поля. Так
вот. Данные должны забираться из источника целиком. Для этого нужна
очень емкая структура для хранения. Подход сейчас я вижу только
один - RDF.

## Классификация<a id="sec-2-4" name="sec-2-4"></a>

Как описывать объекты хранящиеся в системе?

[Онтологии](https://en.wikipedia.org/wiki/Ontology_(information_science)).

Не все файлы нуждаются в семантике. Целая куча постоянно
скачивается, просматривается и удаляется. Нет никакого смысла
наводить на них семантику, кроме может быть примитивной
машинной. Те файлы, которые должны быть упорядочены, должны лежать
в семантическом, тщательно структурируемом хранилище. Все
остальное пускай лежит как раньше.

## Структурирование<a id="sec-2-5" name="sec-2-5"></a>

В какие структуры объединяются ресурсы?

Группировка и сортировка.

Структура информации являются функцией от ее объема. Как только
меняется объем, структуре приходится его догонять. В одной папке с 10
файлами легко найти нужный, в одной папке с 1000 файлами уже не
очень. С другой стороны, если эта 1000 файлов отсортирована по какому-то
признаку, там снова можно ориентироваться.

Сохраненные запросы / Деревья / Контексты

## Поиск<a id="sec-2-6" name="sec-2-6"></a>

Как искать нужную информацию в массиве?

> На больших объемах информации поиск итеративен и разные "мили"
> проходятся разными способами. Полнотекстовый поиск, сохраненные
> запросы и обычный иерархический подход будут мирно сосуществовать
> на машинах. (urbansheep)

## Репрезентация<a id="sec-2-7" name="sec-2-7"></a>

Как отображать данные?

Как нарисовать на экране все то, что у нас есть в базе.

## Аннотирование<a id="sec-2-8" name="sec-2-8"></a>

Как хранить и связывать аннотации с сохраненными ресурсами?

Как аннотировать текст?

Как аннотировать аудио-файлы?

Как аннотировать видео?

Аннотирование в самом простом случае &#x2013; это комментирование.

Как аннотировать обновляющийся источник? Обновляющийся источник
сложно аннотировать. Какие-то части появляются, какие-то
попадают. Последовательная нумерациия параграфов невозможна, потому
что она будет ломаться каждую версию. Значит адресовать нужно по
uuid.

Удобство аннотирования &#x2013; это аргумент в пользу блочной
идентификации. Можно добавлять комментарии к каждому параграфу.

## Переносимость<a id="sec-2-9" name="sec-2-9"></a>

Есть ли импорт и экспорт из хранилища? Можно ли передвинуть данные
куда-то еще?

Я готов вбивать руками семантику на весь свой массив данных, но
только при одном условии: чтобы мне больше никогда не приходилось
это делать.

# Чего мне хочется от информационного менеджера<a id="sec-3" name="sec-3"></a>

## Объединение базы данных и файлового менеджера<a id="sec-3-1" name="sec-3-1"></a>

Есть куча данных, которая не представлена файлами. Письма, записи
из он-лайн сервисов, метрики. Для всего этого лучше подходит формат
базы данных. В файловой системе хранение и классификация
объединены. Если отделить хранение от классификации, то можно
объединять в одну ленту как виртуальные сущности, которые лежат в
БД, как и реальные файлы, представленные в общем-то теми же самыми
записями в БД.

## Блочный текстовый редактор<a id="sec-3-2" name="sec-3-2"></a>

За неимением лучшего описания блочного текстового редактора сошлюсь
пока на заметку Глеба Калинина ["Контент-менеджмент и веб-публикации"](http://glebkalinin.ru/content-management-vs-web-publishing/).

### Зачем бить на блочные элементы<a id="sec-3-2-1" name="sec-3-2-1"></a>

Удобство идентификации &#x2013; можно давать ссылку на конкретное место в
тексте. Например цитаты &#x2013; как пример производного ресурса &#x2013; могут
ссылаться на конкретное место, одкуда они были взяты. Возможность
поставить ссылку на что угодно, начиная от параграфа и элемента
списка до конкретной ячейки таблицы.

Удобство классификации &#x2013; можно навешивать атрибуты на что угодно.

Удобство аннотирования &#x2013; к каждому параграфу можно добавить
аннотацию, например комментарий.

Разбивка на параграфы позволяет строить параллельные тексты. Если
параллелить две книги выглядит как сложная задача, то запараллелить
несколько переводов стихотворения или две цитаты &#x2013; это вполне
посильная задача даже для выполнения руками.

Разбивка на блочные элементы позволяет использовать разные движки
для рендера. Например этот кусок написан textile'ом, тут нужна
подсветка синтаксиса, а это описание графа на языке graphvis,
которое нужно преобразовать картинку в.

## Динамические деревья<a id="sec-3-3" name="sec-3-3"></a>

### Проблемы иерархических файловых систем<a id="sec-3-3-1" name="sec-3-3-1"></a>

Главная проблема здесь в том, что хранение при таком подходе
совмещено с классификацией.

Обычные файловые системы устроены иерархически. В зависимости от
схемы классификации файл можно положить в разные папки. Проблемы
начинаются когда:

-   один и тот же файл можно положить в разные места.
-   изменился объем информации и схему надо детализировать
-   изменился подход и классификацию надо переделывать

Структура &#x2013; это функция от объема информации. Меняется объем &#x2013;
меняется структура.

### Замена одного дерево на множество<a id="sec-3-3-2" name="sec-3-3-2"></a>

Предложение в том, чтобы отделить хранение от классификации и
создавать множество разных деревьев на основе запросов.

На что это похоже: примеры такого уже давно есть в нормальных
музыкальных плеерах, которые предлагают разнообразные способы
отображения коллекции.

Запрос мог бы выглядеть следующим образом:
-   на первом уровне выбери все ресурсы с определенным типом и
    сгруппируй по значению атрибута
-   на втором уровне каждую из получившихся груп сгруппируй по
    значению другого атрибута
-   и т.д.

### Сохранение файловой семантики<a id="sec-3-3-3" name="sec-3-3-3"></a>

Необходимо каким-то образом отображать динамическое дерево в
файловую систему, чтобы все имеющиеся приложения могли работать со
структурой папок, которая генерится запросом.

Обычная проблема каталогизаторов, например calibre, в том, что
доступ к структуре возможен только из интерфейса самого
приложения. Нельзя пойти в папку, соответствующую
`категория/подкатегория/тег` и открыть epub редактором.

1.  FUSE

    Динамические деревья можно отобразить на файловую систему с
    помощью [виртуальной файловой системы](https://en.wikipedia.org/wiki/Virtual_file_system). Под linux это [FUSE](https://en.wikipedia.org/wiki/Filesystem_in_Userspace).

    Биндинги для ruby: [rbusefs](https://github.com/lwoggardner/rfusefs)

    Пример использования: [бесконечные рандомные pdf](https://gist.github.com/teksisto/f35447da6e8079cfbe93)

2.  WebDAV

    Либо, чтобы не связываться с системным программированием, можно
    использовать [WebDAV](https://en.wikipedia.org/wiki/WebDAV), монтировать веб-приложение как папку и снова
    пользоваться ей как файловой системой.

3.  Hard links

    Либо это какой-то менеджер hard links. Под windows жесткие ссылки
    тоже есть, так что возможно это даже кросс-платформенное решение.

    Минус подхода в том, что он работает исключительно для реальных
    файлов, для виртуальных сущностей, типа записей в БД он не
    подходит.

## Контекст<a id="sec-3-4" name="sec-3-4"></a>

Контекст нужен для объединения ресурсов в одно целое и показывает
хронологию развития какой-то темы. Контекст по природе
гетерогенен. Он может захватывать ссылки, картинки, посты, ресурсы
любого типа.

Контекст &#x2013; это легковестный блог с вики-страницей в заголовке.

-   Он предназначен либо для мелкого собирательства, которое возможно
    перерастет во что-то большее (например в заметку). Тогда заметка
    должна стать хедом.

-   Либо для подборки однотипных высказываний (рифмы из цитат). Хотя их можно
    делать и коммуникативными связями.

-   Крупномаштабный харвест всего встреченного на пути по интересной теме.

На что это похоже:
-   tumbler &#x2013; множество блогов у одного пользователя. Маленькие
    блоги на какую-нибудь обскурную тему, в которых есть два поста и
    новые появляются раз в год.
-   redmine &#x2013; страница версии. Там в заголовке вики-страница, а в
    хвосте автоматичекий список задач из спринта, разбитых по типу
    работ.

Атрибуты:

-   название
-   заголовочный блок
-   запрос, определяющий хвост
-   хвост = массив ресурсов

### Заголовочный блок<a id="sec-3-4-1" name="sec-3-4-1"></a>

Заголовочный блок может использоваться как summary или описание
того, зачем контекст нужен.

Так же его можно использовать для агрегирования данных из
элементов хвоста. Например контекст в который входят все
поступления/расходы за месяц может показывать в заголовке график
как менялась сумма денег в кошельке.

Если контекст используется для создания категории постов, то есть
как тег, то он дает некоторые преимущества. Маркер контекста может
быть любым (хоть uuid). В то время как отображаться будет
нормальное название. В головном блоке можно писать что здесь лежит
и зачем.

### Форма быстрого поста<a id="sec-3-4-2" name="sec-3-4-2"></a>

В контексте есть форма быстрого поста. Ты пишешь туда текст, а он
сам разбирается какие атрибуты ему проставить. Интересный вопрос:
как и чем из запроса можно выводить атрибуты, которые присущи новым
записям.

### Хвост<a id="sec-3-4-3" name="sec-3-4-3"></a>

Хвост определяется запросом.

Контекст может захватывать ресурсы автоматически, если ему задать
правила. Например все заметки, которые ссылаются на конкретного
человека.

Контекст умеет показывать хвост в прямом и обратном хронологическом
порядках. Если я нахожу какой-то интересный блог в интернете, как
правило мне хочется читать его с начала.

### Контекст есть у каждого ресурса<a id="sec-3-4-4" name="sec-3-4-4"></a>

Еще одно странное следствие, это то, что контекст есть у каждого
ресурса. То есть есть как минимум какой-то контекст по-умолчанию в
который входят:

-   все ресурсы, которые ссылаются на данный
-   все ресурсы на которые ссылается он сам.

Дело в том, что ни жесткое дерево, ни запутанный граф сами по себе
не подходят для хранения. Часть данных всегда упорядочена, часть
связей всегда нарушает иерархию. То есть получается дерево,
опутанное дополнительными связями между узлами. Это всевозможный
cross-referencing, ассоциативные связи и прочее случайное, что
может объединять узлы. Тот контекст, который есть у каждого узла
&#x2013; это те самые случайные связи.

### Контекст как строительный блок интерфейса<a id="sec-3-4-5" name="sec-3-4-5"></a>

Получается, что контекст &#x2013; это один из основных строительных
блоков интерфейса. Потому что любые коллекции (eg список
полученных/отправленных писем для человека) &#x2013; это фильтр, который
вытаскивает сущности из базы и показывает в хедере статистику.

### Динамическое дерево как вложенные контексты<a id="sec-3-4-6" name="sec-3-4-6"></a>

Интересно, что дерево вложенных контекстов &#x2013; это и есть то самое
динамическое дерево.

Новые сущности просеиваются сначала сквозь фильтр первого
контекста, потом через фильтры вложенных контекстов и где-то
оседают. Механизм просеивания &#x2013; это детали реализации.

Еще раз. Контекст гетерогенен. Ему без разницы что засасывать,
потому что засасывает он ресурсы, адресуемые uuid. Поэтому ничто
не мешает ему содержать в себе другие контексты.

В этом случае, кстати, голова контекста является элементом,
отображаеммым в ленте контекста верхнего уровня. Не надо так же
забывать, что голова контекста &#x2013; это обычный ресурс и у него, как
и у любого друго ресурса могут быть разные вьюшки для
отображения. Что позволяет например ужать в графическом
представлении весь контекст до заголовка со ссылкой.

## Параллельные тексты<a id="sec-3-5" name="sec-3-5"></a>

Под текстом здесь понимается любая информация, упорядоченная
последовательно.

Примеры параллельных текстов:

-   запись выступления и презентация
-   песня и ее текст
-   подкаст и трансрипт
-   фильм, аудио дорожки к нему и субтитры
-   цитата на двух языках
-   книга на двух языках

Есть утилиты, которые строят параллельные тексты на разных языках
автоматически. Например, параграф к параграфу. Как я предполагаю,
они делают это на основе грубого машинного перевода и вычисления
насколько параграфы идентичны.
-   [Abbyy Aligner](http://www.abbyy.com/aligner/)
-   [Supernova Aligner](http://www.supernova-soft.com/wpsite/products/text-aligner/create-parallel-text-for-language-lerning/)

Ссылки:
-   [Parallel text](https://en.wikipedia.org/wiki/Parallel_text)
-   [Обучение через чтение параллельных текстов](https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D1%82%D0%B5%D0%BA%D1%81%D1%82_(%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B8%D0%BA%D0%B0_%D0%BE%D0%B1%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D1%8F))
-   [Ted Nelson &#x2013; My parallel universe](http://ted.hyperland.com/myU/)

# Что бы я со всем этим делал<a id="sec-4" name="sec-4"></a>

## Оглавления для источников<a id="sec-4-1" name="sec-4-1"></a>

В идеале книги должны импортироваться внутрь, биться на блочные
элементы и цитаты должны привязываться непосредственно к тому
пераграфу, откуда она была вытащена. Но это непростая операция,
даже если на входе epub.

Поэтому делается упрощенный вариант: от книги оставляется скелет
в виде оглавления.

Речь про то, что должен быть выбор: либо источник создается без
оглавления, либо есть оглавление, либо полный импорт.

Как достать оглавление:
-   [PDF](https://stackoverflow.com/questions/2431426/extract-toc-of-pdf) (`mutool show file.pdf outline`)
-   [EPUB](http://www.idpf.org/accessibility/guidelines/content/nav/toc.php) (здесь это xml-файл, лежащий в архиве)
-   FictionBook (опять xml)

## Конспекты<a id="sec-4-2" name="sec-4-2"></a>

Конспект точно так же привязывается к оглавлению, как и
цитаты.

В итоге к оглавлению привязываются: сам текст с возможностью
комментирования любого параграфа и отсылками к заметкам, цитаты,
новые слова, события, ссылки, карточки персоналий.

## Цитатник<a id="sec-4-3" name="sec-4-3"></a>

### Привязка цитат к оглавлению книги<a id="sec-4-3-1" name="sec-4-3-1"></a>

Цитаты привязываются к оглавлению источника.

### Заголовки для цитат<a id="sec-4-3-2" name="sec-4-3-2"></a>

Простая фича, но мне ее не хватает (например в tumbler). Обычно я
делаю заголовки в формате "#{автор} про #{тема}".

### Форматирование внутри цитат<a id="sec-4-3-3" name="sec-4-3-3"></a>

Чтобы подсвечивать болдом/цветом куски текста и
вставлять/сохранять ссылки.

Паттерн "куда смотреть".

### Параллельные цитатники<a id="sec-4-3-4" name="sec-4-3-4"></a>

Параллельные цитатники позволяют отображать версии одной и той же
цитаты на разных языках. Напрмер чтобы сравнивать перевод и
оригинал. Цитата по-прежнему является отдельной сущностью и
крепится к оглавлению.

[Пример параллельного цитатника](https://htmlpreview.github.io/?https://github.com/teksisto/timeline/blob/master/misc/parallel_quotes/quotes.html) из книги Пирсига "Дзен и искусство
ухода за мотоциклом". Поскольку не существует электронной версии
перевода Горшкова я выписывал русские аналоги только для коротких
цитат.

### Колоды<a id="sec-4-3-5" name="sec-4-3-5"></a>

Колоды из цитат. Я называю это колодами, потому что когда-то
печатал цитаты на карточках. Получалось что-то вроде карточной
колоды. На самом деле это просто возможноть объединить
произвольные цитаты в группу и добавить к ней описание.

### Рифмы<a id="sec-4-3-6" name="sec-4-3-6"></a>

Если долго собирать цитаты между ними начинают проглядывать
параллели. Есть мнение что люди часто говорят про одни и те же
вещи, просто называют их по-разному. Хотелось бы помечать такие
находки в цитатнике связями, а потом обсуждать и оценивать
такие связи.

Похожесть цитат не обязательно транизитивное свойство, но
предполагаю, что для нескольких человек на относительно больших
наборах цитат будут находится не только пары, но цепочки из цитат.

> Reed College at that time offered perhaps the best calligraphy
> instruction in the country. Throughout the campus every poster,
> every label on every drawer, was beautifully hand
> calligraphed. Because I had dropped out and didn't have to take
> the normal classes, I decided to take a calligraphy class to learn
> how to do this. I learned about serif and san serif typefaces,
> about varying the amount of space between different letter
> combinations, about what makes great typography great. It was
> beautiful, historical, artistically subtle in a way that science
> can't capture, and I found it fascinating.
>
> None of this had even a hope of any practical application in my
> life. But ten years later, when we were designing the first Macintosh
> computer, it all came back to me. And we designed it all into the
> Mac. It was the first computer with beautiful typography. If I had
> never dropped in on that single course in college, the "Mac" would
> have never had multiple typefaces or proportionally spaced fonts. And
> since Windows just copied the Mac, it's likely that no personal
> computer would have them. If I had never dropped out, I would have
> never dropped in on that calligraphy class, and personal computers
> might not have the wonderful typography that they do. Of course it was
> impossible to connect the dots looking forward when I was in
> college. But it was very, very clear looking backwards 10 years later.
> Again, **you can't connect the dots looking forward**;
> you can only connect them looking backwards. So you have to trust that
> the dots will somehow connect in your future. You have to trust in
> something – your gut, destiny, life, karma, whatever – because
> believing that the dots will connect down the road will give you the
> confidence to follow your heart, even when it leads you off the
> well-worn path, and that will make all the difference.
>
> (Steve Jobs, [Commencement Address at Stanford University](http://www.americanrhetoric.com/speeches/stevejobsstanfordcommencement.htm))

> What you’re supposed to do in most freshman-rhetoric courses is to
> read a little essay or short story, discuss how the writer has done
> certain little things to achieve certain little effects, and then have
> the students write an imitative little essay or short story to see if
> they can do the same little things. He tried this over and over again
> but it never jelled. The students seldom achieved anything, as a
> result of this calculated mimicry, that was remotely close to the
> models he’d given them. More often their writing got worse. It seemed
> as though every rule he honestly tried to discover with them and learn
> with them was so full of exceptions and contradictions and
> qualifications and confusions that he wished he’d never come across
> the rule in the first place.
>
> A student would always ask how the rule would apply in a certain
> special circumstance. Phædrus would then have the choice of trying to
> fake through a made-up explanation of how it worked, or follow the
> selfless route and say what he really thought. And what he really
> thought was that **the rule was pasted on to the writing after
> the writing was all done**. It was post hoc, after the fact,
> instead of prior to the fact.
>
> (Robert M. Pirsig, [Zen and the Art of Motorcycle Maintenance](http://design.caltech.edu/Misc/pirsig.html))

### Компартментализм<a id="sec-4-3-7" name="sec-4-3-7"></a>

Термин из психологии. По-русски обычно переводят как "раздельное
мышление". Типовые примеры из википедии: чудеса гуманизма в
общественной деятельности, сочетающиеся с домашним насилием и
жестокостью; борьба с порнографией, сочетающаяся с обширной
домашней коллекцией порно.

Если долго собирать цитаты, в них начинают появляться
противоположные. Иногда один и тот же человек с течением времени
высказывает противоположные взгляды (это нормально, он растет и
меняется).

Идея игры в том, что брать цитаты из разных мест и укладывать их в
два столбика &#x2013; за и против. Потом смотреть на то, как по любому
вопросу есть две противоположных точки зрения, представленные
вполне убедительными людьми. Может быть даже в три столбика: за,
против и синтез &#x2013; но попыток синтеза вокруг очень мало. Хотя идея
"срединного пути" совсем не нова, и была озвучена как упоротыми
изотериками, так и психотерапевтами.

Я дошел до этой игры сам, но позже обнаружил, что уже есть сервис
реализующий похожий подход &#x2013; lovehate.ru. Там обитает много
школьников, что конечно его портит.

Играть в эту игру можно просто с самим собой, находя противоречия
как в себе, так и в окружающем мире. Но есть и вторая цель &#x2013;
сделать какой-то аналог [дискуссионного клуба](https://en.wikipedia.org/wiki/Debate#Student_debating_societies). Сбор best arguments,
за и против какой-нибудь идеи.

Конечная цель игры &#x2013; синтез разных мнений.

> Раздельное мышление — это защитный механизм,
> позволяющий человеку умещать в себе логически несовместимые
> установки. Если по каким-то причинам человек нуждается в каждой из
> своих несовместимых установок, то осознание возникающего
> противоречия начинает занимать мысли попытками это противоречие
> разрешить (зачастую с помощью рационализаций). Чтобы этого не
> происходило, человек может начать «раздельно мыслить» — не
> осознавая противоречия между ними, придерживаться всех
> несовместимых установок сразу. Со стороны это выглядит как простое
> лицемерие, но сам человек в этом случае придерживается своих
> установок вполне искренне, хотя и использует в каждом конкретном
> случае только одну из них.
>
> (Википедия, Мак-Вильямс)

> Настоящий спор, говорю тебе из лагерного опыта, производится
> как поединок. По согласию выбираем посредника &#x2013; хоть Глеба
> сейчас позовем.  Берем лист бумаги, делим его отвесной чертой
> пополам. Наверху, через весь лист, пишем содержание
> спора. Затем, каждый на своей половине, предельно ясно и
> кратко, выражаем свою точку зрения на поставленный
> вопрос. Чтобы не было случайной ошибки в подборе слова &#x2013;
> время на эту запись не ограничивается. [&#x2026;] Пустые
> словопрения и сотрясения воздуха могут тянуться неделями. А
> спор на бумаге иногда кончается в десять минут: сразу же
> становится очевидно, что противники или говорят о совершенно
> разных вещах или ни в чем не расходятся. Когда же выявляется
> смысл продолжать спор &#x2013; начинают поочередно записывать доводы
> на своих половинках листа.
>
> (Солженицин, "В круге первом")

## События<a id="sec-4-4" name="sec-4-4"></a>

Я прочитал несколько книг про историю компьютеров и сетей и понял,
к моменту прочтения последней, я уже не могу сопоставить даты,
которые мне описывают сейчас, с датами, которые были описаны в
предыдущих книгах. Было бы круто наложить последовательности
событий друг на друга и показать это все на таймлайне.

Проблема в том, что когда я слышу, что "Хоббит" был опубликован в
1937 году, я уже давно забыл, что в том же году вышла первая
диснеевская полнометражка. События, даты которых я слышу, для меня
находятся в вакууме. Если их выписывать, то со временем контекста
будет становится все больше.

Так же это здорово прочищает мозг, потому что выясняется с какой
легкостью я ошибаюсь на плюс-минус десять лет в интуитивной оценке,
когда что-то произошло.

Кое-как, но события сейчас реализованы. Их можно добавлять,
разглядывать на таймлайне через [vis.js](http://visjs.org), и крепить вместе с цитатами
к оглавлению книги.

![img](../images/timeline/timeline1.png)

## Словарь<a id="sec-4-5" name="sec-4-5"></a>

### Личный словарь терминов<a id="sec-4-5-1" name="sec-4-5-1"></a>

Карточки для терминов, встреченных в тексте. Крепятся к
оглавлению. Автоматически генерируют ссылки на запрос в гугл и
википедию.

### Словарь иностранных слов<a id="sec-4-5-2" name="sec-4-5-2"></a>

Например берем субтитры на английском, тупо режем их на слова и
удаляем всякий очевидный мусор. ﻿Прикручиваем [WordNet﻿](https://wordnet.princeton.edu/). Удаляем
множественные числа, превосходные степени, глагольные формы,
междометия, предлоги и местоимения. Считаем частотность. Находим
самые частовстречающиеся 2000 слов (["core vocabulary"](https://en.wikipedia.org/wiki/Basic_English)). Делаем
интерфейс, в котором пользователь может отметить знает он это
слово или не знает (там не надо думать, если сомневаешься,
говоришь, что не знаешь). На вычитку 1000 слов у меня уходило
меньше часа. Предположим, что средний словарный запас у
англоговорящего 20-30k слов, у того кто учит язык &#x2013; сильно
меньше. За 10-20 часов систему можно научить всем словам, которые
ты знаешь. По сравнению со временем обучения языку это очень мало.

Ок, на выходе мы получили список слов. Что теперь с ним можно
поделать?

Во-первых, можно прогнать свежий текст через базу и найти слова,
которых ты не знаешь. Если прикрутить [treat](https://github.com/louismullie/treat), то еще и с частью
речи. Теперь можно автоматом генерить из них карточки для
запоминания, в которых будет учитываться часть речи ("мне
встречалось это слово как глагол, а тут оно как существительное"),
автоматически добавляться пример в котором слово попалось и будет
стоять ссылка на конретный источник, откуда слово взялось. Это
очень круто, потому что руками делать карточки вымораживает. Из
упоротых идей: можно скриншот делать из видео, где это слово
показыватеся.

Во-вторых, можно оценивать лексическую сложность текста до
прочтения.

В-третьих, можно понимать какие слова учить первыми, потому что
они чаще встречаются.

На картинке синяя часть полоски &#x2013; это базовая лексика, красная &#x2013;
слова, которые повторяются два и больше раз, и желтая &#x2013; слова,
которые встречаются в сериале один раз.

![img](../images/words/words.png)

## Импорт данных из веб-сервисов<a id="sec-4-6" name="sec-4-6"></a>

О плохом сервисе никто не знает, хороший закроется через 10
лет. Плохой сервис не отдает данные пользователям, хороший имеет
выгрузку данных и api. Но что с ними делать, если он все равно
закрылся? Интерфейс пропал. Что делать с несколькими
экспортированными наборами данных, если хочется единую ленту?

Примеры веб-сервисов, которые пытались делать единую ленту: Singly,
Locker, Memolane, FriendFeed. В настоящий момент все закрыты.

Помимо единой ленты есть еще проблема единых метаданных. Теги из
разных сервисов надо приводить к одному знаменателю.

# Поиск подхода к реализации<a id="sec-5" name="sec-5"></a>

Самое вменяемое решение, которое я вижу &#x2013; это [RDF](https://en.wikipedia.org/wiki/Resource_Description_Framework).

## Декомпозиция<a id="sec-5-1" name="sec-5-1"></a>

### Блог<a id="sec-5-1-1" name="sec-5-1-1"></a>

Представим себе блог, где каждый пост не является монолитом, а
собирается из кусочков-атомов. Каждый атом имеет уникальный
идентификатор, хранится отдельно и имеет свой набор
атрибутов. Каждый параграф, картинка, видео-ролик в посте – это
атом. Структура поста задается списком из уникальных идентификаторов
каждого атома, каждый из которых трансклюдится в пост. На каждый
параграф в посте можно сослаться, навесить атрибуты и добавить
комментарии.

Структура каждого комментария к посту повторяет его структуру. К
этому добавляется древовидный или линейный контейнер, который хранит
порядок комментариев.

Посты организуются в хронологическое дерево. Это может быть
стандартная схема год/месяц/день или какая-нибудь другая, например,
год/неделя/день. Деревьев может быть несколько, выбор определяется
удобством.

Какие элементы структуры имеем в результате?

-   атомы с атрибутами
-   линейный список для объединения атомов в посты
-   комментарии, каждый из которых повторяет структуру поста
-   дерево для комментариев
-   посты организуются в хронологическое дерево

Теперь отрезаем лишние сущности.

Между атомом и постом нет никакой разницы. Оба имеют уникальный
идентификатор и набор атрибутов. Разница только в том, что у поста
есть сложный атрибут, который хранит список входящих в него
атомов. Сущность, обладающую уникальным идентификатором, на которую
можно навесить атрибуты я дальше буду называть ресурсом.

Между деревом и линейным списком нет никакой разницы, поскольку
дерево – это просто список списков. Дерево комментариев – это список
списков, листьями которого являются ресурсы, содержащие комментарии.

Теперь у нас есть два вида ресурсов: посты и комментарии. На самом
деле, даже больше, потому что атомы тоже различаются – текст,
картинка, видео. Поскольку у нас есть несколько типов ресурсов,
логично ввести понятие тип ресурса. Определение ресурса расширяется
до сущности, у которой есть уникальный идентификатор, атрибуты и
тип. Тип – это такой же атрибут, как и дата создания, заголовок или
любая другая мета-информация. Отличает его только то, что он
является обязательным, поскольку без него мы не будем знать, как
обрабатывать ресурс. Допустим, мы генерируем на основе нашей
структуры html. Чтобы отобразить текстовый атом, надо преобразовать
содержащуюся в нем разметку (например markdown) в html, обернуть
это в div и отдать браузеру. Чтобы показать картинку, надо обернуть
ее в тег img и отдать браузеру. Разница в обработке закрепляется в
виде типа.

Атрибуты — это, строго говоря, тоже ресурсы, а линейные списки
создаются с помощью цепочек ресурсов, ссылающихся друг на друга. Так
что кроме ресурсов ничего особо и не остается, но атрибуты и
линейные списки мы выкидывать пока не будем, а то говорить не о чем
будет.

Итак, у нас остались:

-   ресурсы
-   атрибуты
-   линейные списки

Переводим в термины rdf:

-   ресурс по-прежнему остается ресурсом (rdf:Resource)
-   атрибуты в терминологии rdf называются rdf:property
-   атрибут «тип ресурса» – это rdf:type
-   ресурсы, описывающие атрибуты, имеют rdf:type равным rdf:Property

Схема получается довольно заманчивая, потому что в базе данных все
поместится в две таблицы: одна для графа и одна для сопоставления
идентификаторов атомов и все было бы хорошо, если бы речь шла про
однопользовательскую систему, например, если бы мы говорили про
гибкую структуру для бекапа различных блогов. Но у блога есть
комментарии и пользователей много. Нужно разграничение
доступа. Красивая схема «все в двух таблицах» разваливается. Права —
зло, про них придется думать отдельно.

Чтобы два раза не вставать, сразу скажу, что в смысле бекапа блог не
сильно отличается от твиттера, френдфида, фликра и многого
другого. Все упирается в модель безопастности.

### Оценка количества триплетов при импорте книги<a id="sec-5-1-2" name="sec-5-1-2"></a>

На примере книги ["Learning SPARQL"](http://www.learningsparql.com/).

Поиск блочных элементов:

    cat OEBPS/*html > all
    grep -cP '<img|<ol|<li[>\s]|<ul[>\s]|<p[>\s]|<pre[>\s]|<h\d[>\s]|<dd|<dt|<table|<tr|<td' all
    => 2363 <1>

Количество заголовков в оглавлении:

    grep -cP '<a' bk01-toc.html
    => 268

Получается в среднем около 8 блочных элементов на элемент
заголовка. Предположим, что большинство элементов прикреплены к
заголовкам третьего уровня. (Уровень заголовка считается от единицы.)

hasPart / isPartOf. Формула: `2 * n * (d + 1)` Каждый блочный элемент
принадлежит своему заголовку и всем его родительским.

    2 * 2363 * (3 + 1) = 18904 <2>

Теперь у нас есть количество элементов и есть связи. Надо какие-то
индексы, чтобы сортировать части внутри заголовка. Придется
использовать упоротую систему нумерации из rdf, где для описания
связи двух элементов нужно три триплета.

    (2363-1) * 3 = 7086 <3>

С учетом того, что информация про язык, авторов и так далее не
подвергается инференсингу, то в сумме получается:

    2363 + 18904 + 7086 = 28353

30k триплетов на одну книгу. На 1k книг &#x2013; 30 000 000 триплетов.

## Базовые определения<a id="sec-5-2" name="sec-5-2"></a>

### Ресурс<a id="sec-5-2-1" name="sec-5-2-1"></a>

Отдельная сущность, адресуемая уникальным идентификатором. Роль
идентификатора выполняет URI.

Имеет множество атрибутов в формате ключ=значение.

Имеет множество представлений.

Ресурс имеет класс, который определяет его базовый логический
тип. Класс определяет какие атрибуты можно вешать на этот ресурс и
с помощью каких представлений его рисовать.

Идентификатор позволяет выцепить из источника данных настоящий
контент, соответствующий ресурсу. Это так называемый dereferencing.

Контент есть только у неделимых ресурсов, то есть на самом деле не
у всех. Контент есть у ресурса, являющегося параграфом текста,
картинкой, аудио-файлом, видео-файлом. Для ресурсов, у которых нет
контента, устанавливается некий пустой адаптер.

### Представление<a id="sec-5-2-2" name="sec-5-2-2"></a>

У ресурса есть класс. Классу соответствует множество представлений,
из которого выбирается нужное. Представление &#x2013; это шаблон, который
получает на входе ресурс, достает из него хеш с атрибутами, с
помощью адаптера получает контент и рисует из всего этого html.

У одного ресурса есть множество представлений.

Три стандартных, которые показывают ресурс вне зависимости от того
есть у него класс или нет:

1.  `default` &#x2013; показывает атрибуты и контент. Атрибуты содержащие
    ссылки на другие ресурсы показываются просто ссылками и никак не
    отображаются.
2.  `inline` &#x2013; показывает только контент. Для параграфа это текст в
    теге `<p>`, для картинки тег `<img>` и так далее.
3.  `link` &#x2013; показывает только ссылку на ресурс.

Расширенные, опирающиеся на класс:

1.  `classed-link` &#x2013; отображает иконку рядом со ссылкой в зависимости
    от типа ресурса.
2.  `card` &#x2013; показывает некоторую компактную summary по ресурсу и
    ссылку на полную версию. Например для книги это может быть
    обложка, под которой написано полное название и год
    издания. Карточки используются при отображении "плитки" из
    ресурсов.
3.  `classed-link-with-card` &#x2013; `classed-link` у которой при навении
    мышки на ссылку появляется карточка во всплывающем окне.

### Атрибут<a id="sec-5-2-3" name="sec-5-2-3"></a>

Атрибут тоже ресурс. На него тоже можно навешивать атрибуты.

Адаптер для него HTTP, потому что так сложилось.

Формат атрибута `<attribute>=<value>`. UUID ресурса плюс ключ и значение
образовывают триплет.

### Адаптер<a id="sec-5-2-4" name="sec-5-2-4"></a>

URI состоит из NID и NSS.

NID &#x2013; namespace id. Позволяет выбрать адаптер для совершения с ресурсом базовых
действий.

NSS &#x2013; namespace spicific string. Позволяет однозначно ссылаться на
ресурс внутри определенного namespace.

Основные действия, которые должен поддерживать ресурс:

-   создание
-   чтение
-   редактирование
-   удаление

Действия над метаданными внутри ресурса:

-   добавить единицу метаданных в формате ключ=значение
-   вернуть значение по определенному ключу
-   считать все метаданные и вернуть хеш
-   установить значение по определенному ключу
-   удалить единицу метаданных по ключу

Некоторые ресурсы могут не поддерживать метаданные (plain text) или
быть недоступными для удаления/редактирование (страница в
интернете). В этом случае адаптер просто не поддерживает эти
операции.

# Как это все может выглядеть на практике<a id="sec-6" name="sec-6"></a>

RDF &#x2013; это идея, что данные хранятся в графе. Хранить этот граф и
управлять им можно по-разному.

## Реляционный подход<a id="sec-6-1" name="sec-6-1"></a>

Лучше всего про реляционный подход написал какой-то чувак с [HN](https://news.ycombinator.com/item?id=10326764):

> Having a completely abstracted database with one big
> table called "things" and another big table called "relationships"
> seems really attractive before you actually do it. Then it starts
> to suck.

Все хранится в трех таблицах: `Resources`, `Properties`, `Trees`.

`Trees` &#x2013; это оптимизация, которая позволяет хранить деревья,
упорядоченные и не упорядоченные списки, не прибегая к упоротому
способу `rdf:next`.

В таблице `Resources` включен single-table inheritance, который
выгружает ресурсы в соответствующие ruby-классы.

Валидации делаются засчет того, что у ресурсов типа `Property` в
классах есть методы в духе `domain` и `range`, которые возвращают
множества того, что можно крепить к свойству слева и справа
соответственно.

Инферинг делается в духе:

    after_create :add_inverse_property

У классов нет множественного наследования. Мне оно строго говоря и
не нужно, но реализовывать проще, если принять это
ограничение. Правда придется разруливать два триплета с которых
вообще начинается вся семантика. Потом все нормально.

### Конспект<a id="sec-6-1-1" name="sec-6-1-1"></a>

Сначала у нас есть один ресурс &#x2013; книга. У него есть атрибут `content`
в котором лежит ссылка на дерево.

Ссылка на дерево &#x2013; это указатель на анонимный корневой элемент
дерева, к которому крепятся его элементы. У элемента дерева, помимо
информации о вложенности есть только одна полезная нагрузка &#x2013;
ссылка на ресурс.

Мы делаем первый запрос и получаем из ресурса класса `Book` ресурс
класса `Outline`.

Мы делаем второй запрос и получаем свойство `content` ресурса класса
`Outline`. В нем хранится ссылка на дерево.

Мы делаем третий запрос и получаем упорядоченный массив
элементов дерева, потому что nested set. Ресурсы крепятся к
элементам дерева с помощью `includes`. Для этого нужен один `join`.
На выходе получаем массив элементов дерева, с уже загруженными из
базы элементами типа `Paragraph`, `Section` или `List`.

### Цитаты, разложенные по главам<a id="sec-6-1-2" name="sec-6-1-2"></a>

У цитаты есть функциональное свойство источник. Функциональное в
том смысле, что оно у него может быть только одно, потому что у
цитаты есть только один источник.

Цитата крепится свойством `source` к элементу оглавления класса
`Section`. Оглавление в книге одно на всех. К нему крепятся и
конспекты, и цитаты, и контент. Это означает, что элемент
оглавления должен иметь свой тип и свои свойства, к которым
крепятся соответствующие деревья.

Допустим он имеет тип `Section`. У `Section` есть четыре атрибута:
`dc:title`, `my:content`, `my:outlite`, `my:quotes`.

Первый запрос: взять у книги атрибут `оглавление` и достать оттуда
ссылку на анонимный элемент дерева, который хранит все элементы
оглавления класса `Section`.

    resource[toc] = tree_id

Второй запрос: прийти в таблицу деревья и вытащить оттуда всех
детей этого анонимного элемента, сделав на них `inludes`, что дает
нам все ресурсы описывающие главы. Это первый `join`.

    tocs = Tree.find(tree_id).descendants.includes(r)

Третий запрос: из каждого ресурса типа `Section` надо достать
свойство `quotes`, которое ссылается на анонимный элемент дерева,
который хранит список элементов класса `Quote`, который нам и нужен.

## Обычный реляционный подход + наведенная семантика<a id="sec-6-2" name="sec-6-2"></a>

Объекты каждого класса хранятся в отдельной таблице, связи между
ними во внешних ключах. Связи лежат в коде. Новый класс &#x2013; новый
скаффолд. Ограничения разползаются в валидации и колбеки.

На сервере стоит вордпресс, редмайн и медиавики. Делается точка
доступа `sparql`, которая маппит их таблицы в rdf и предоставляет
унифицированный доступ. На основе этой точки доступа рисуется
интерфейс.

Основная проблема этого подхода в невозможности импорта данных из
какого-то источника без изменения схемы хранения данных. Если схему
не менять, то при импорте либо часть данных потеряется, либо
придется менять их семантику. Например у нас есть хранилище,
заточенное под wordress, а импортировать туда надо записи из
livejournal, и поле "current mood" приходится класть прямо в текст
записи, потому что мы не можем его добавить не программируя.

## Семантика<a id="sec-6-3" name="sec-6-3"></a>

[Триплстор](https://en.wikipedia.org/wiki/Triplestore), [ризонер](https://en.wikipedia.org/wiki/Semantic_reasoner), запросы на [SPARQL](https://en.wikipedia.org/wiki/SPARQL). Интерфейс на
рельсах. Моделей нет. Контроллер по сути один &#x2013;
`ResourcesController`. В основном надо рисовать партиалы для
отрисовки ресурсов конретного класса с указанной детализаций и
связанными ресурсами.

### OpenLink Virtuoso<a id="sec-6-3-1" name="sec-6-3-1"></a>

<http://virtuoso.openlinksw.com/>

### Stardog<a id="sec-6-3-2" name="sec-6-3-2"></a>

<https://www.stardog.com>

Платная.

> It supports both semantic graphs, via RDF, SPARQL, and OWL, as
> well as property graphs via Apache TinkerPop and Gremlin&#x2013;it's
> the **only graph database that supports both models over the same
> database, simultaneously**.
>
> &#x2013; <http://tinkerpop.apache.org/providers.html>

> Stardog supports integrity constraint validation as a data
> quality mechanism via **closed world** reasoning.

### AllegroGraph<a id="sec-6-3-3" name="sec-6-3-3"></a>

<http://franz.com/>

Выглядит вполне живым. Копирайт на сайте обновляется, есть всякие
видео и список событий. Есть community версия и платная. Внезапно
есть биндинги для Common Lisp и курсы по изучению Common Lisp.

## Графовая база данных<a id="sec-6-4" name="sec-6-4"></a>

Если конкретнее, то [neo4j](https://neo4j.com). Про графовые базы
пишут, что если цепочки связей между ресурсами больше двух, то
можно использовать, а если нет, тогда postgres. То есть
хранить там все нет смысла.

Использует собственный язык запросов [Cypher](https://neo4j.com/docs/developer-manual/current/cypher/). Говорят, что
поддерживает SPARQL.

Подозрение вызывает то, что связи не являются узлами как в RDF. На
них можно навешивать атрибуты, но это каждый раз происходит
локально для каждой созданной связи. То есть метаинформацию кто и
когда добавил связь оставить можно, но нельзя сказать, что эта
связь соединяет только определенные узлы. Эта информация уходит в
логику приложения.

С другой стороны это радикально упрощает provenance. Нет этой
упоротой rdf-схемы, где для описания одной связи надо использовать
4+n триплетов, (n &#x2013; количество триплетов с мета-информацией, 4 &#x2013;
statement + subject + predicate + object). Как оно устроено внутри,
мне не интересно, главное что думать про это не надо будет.

Очень привлекают примеры с быстрой загрузкой данных из WordNet и
dbpedia.

Определенно хорошо применять для:
-   связей между цитатами
-   связей между параграфами

Книга O'Reilly "Graph Databases" &#x2013; это введение в neo4j.

Обертка для ruby: [neo4jrb](https://github.com/neo4jrb/neo4j) ([docs](https://neo4jrb.readthedocs.io/en/7.1.x/) / [блог на neo4jrb за 10 минут](https://www.youtube.com/watch?v=bDjbqRL9HcM))

# История<a id="sec-7" name="sec-7"></a>

## (1945) Vannevar Bush — As We May Think<a id="sec-7-1" name="sec-7-1"></a>

The Atlantic: [As We May Think](http://www.theatlantic.com/magazine/archive/1945/07/as-we-may-think/303881/)

Wikipedia: [Memex](https://en.wikipedia.org/wiki/Memex)

## (1967) Andries van Dam, Ted Nelson — Hypertext Editing System<a id="sec-7-2" name="sec-7-2"></a>

Wiki: [HES](https://en.wikipedia.org/wiki/Hypertext_Editing_System)

## (1968) Douglas Engelbart — oN-Line System<a id="sec-7-3" name="sec-7-3"></a>

Wiki: [The Mother of All Demos](https://en.wikipedia.org/wiki/The_Mother_of_All_Demos) / [oN-Line System](https://en.wikipedia.org/wiki/NLS_(computer_system))

Видео: <http://www.1968demo.org/>

## (1968) Andries van Dam — File Retrieval and Editing System<a id="sec-7-4" name="sec-7-4"></a>

Wiki: [FRESS](https://en.wikipedia.org/wiki/Hypertext_Editing_System)

## (1985) Intermedia<a id="sec-7-5" name="sec-7-5"></a>

> In 1983 Andries van Dam, William S. Shipp and Norman Meyrowitz founded
> the Institute for Research in Information and Scholarship (IRIS) at Brown.
> Their most notable project was Intermedia, a networked, shared, multiuser
> hypermedia system explicitly designed for use within university research and
> teaching environments. Intermedia was started in 1985 and sponsored by the
> Annenberg/CPB project and IBM (Meyrowitz 1986, 196).

Wiki: [Intermedia](https://en.wikipedia.org/wiki/Intermedia_(hypertext))

## (1991) Gifford — Semantic file systems<a id="sec-7-6" name="sec-7-6"></a>

Старая заметка про Гиффорда:

> Подход, описанный Гиффордом, можно наглядно продемонстрировать
> на примере del.icio.us. Факт того, что он писал это еще в 1991
> году, убивает на фиг. Но. Главный недостаток этого подхода
> заключается в том, что когда множества полей (fields) и их
> значений (values) выростет, системой будет невозможно
> пользоваться. Это видно и на примере делишеса. Никто не
> пользуется инкрементным поиском. Это прикольно, но медленно и
> нафиг никому не сдалось. Проблема инкрементного поиска в том,
> что вылезает слишком много не нужных параметров.
>
> Сохраненные запросы имеют то преимущество перед подходом Гиффорда, что
> они заранее отсеивают ненужные параметры поиска. Дело не в том, что
> дерево &#x2013; это плохо. Дело в том, что одно дерево это плохо. Деревьев
> должно быть много. В файловую систему из можно интегрировать с помощью
> виртуальных файловых систем.

## (1993) LDAP<a id="sec-7-7" name="sec-7-7"></a>

LDAP интересен своей способностью строить классицификаторы. Там
есть классы, наследование, всякие прочие штуки. Для 1993 года
неплохо.

Wiki: [LDAP](https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol)

[LDAP for Rocket Scientists](http://www.zytrax.com/books/ldap/)

## (1996) Eric Freeman and David Gelertner — Lifestreams<a id="sec-7-8" name="sec-7-8"></a>

Wiki: [Lifestreaming](https://en.wikipedia.org/wiki/Lifestreaming)

## (1999) Presto<a id="sec-7-9" name="sec-7-9"></a>

Paul Dourish, W. Keith Edwards, Anthony LaMarca and Michael
Salisbury. Xerox Palo Alto Research Center.

[Presto: An Experimental Architecture for Fluid Interactive Document Spaces](http://www.dourish.com/publications/1999/tochi-presto.pdf)

## (2000) id3v2.4<a id="sec-7-10" name="sec-7-10"></a>

Informal standard на теги для mp3 файлов. Не смотря на то, что
структура метаданных хорошо прописана, по большому счету ее никто
не использует.

Проблема метаданных для музыки &#x2013; обширная тема, надо ее чуть позже
раскрыть.

<http://id3.org/id3v2.4.0-frames>

## (2000) MusicBrainz<a id="sec-7-11" name="sec-7-11"></a>

Отлично прописанная онтология для музыки. Last.fm забирает данные
именно отсюда.

<https://musicbrainz.org/>

## (2001) Eric Kim — Purple<a id="sec-7-12" name="sec-7-12"></a>

Подход к решению проблемы идентификации частей документа. Добавляет
для блочных элементов в html якоря со ссылками. Реализация идеи Нельсона.

<https://en.wikipedia.org/wiki/Purple_Numbers>

## (2001) Tim Berners-Lee — Semantic Web<a id="sec-7-13" name="sec-7-13"></a>

## (2001) Tinderbox<a id="sec-7-14" name="sec-7-14"></a>

По сути &#x2013; mindmap. Есть заметки, у них есть классы (прототипы на
местном сленге) и аттрибуты. Из классов можно делать иерархии.

Есть несколько способов отображения заметок: mindmap (с
возможностью заныривания в поддерево), timeline, outline, карта. В
смысле отображение Tinderbox хорош, хотя он упускает один важный
способ отображения &#x2013; лента.

Между заметками можно делать связи. Связи можно делать между любыми
заметками, даже если они находятся на разных уровнях иерархии. Есть
инспектор, который показывает все входящие и исходящие связи для
конкретной заметки.

Tinderbox не является редактором гипертекста (и тем более блочным
редактором), связи у него существуют только на уровне
заметок. Метаданные тоже можно навешивать на уровне заметок. Текст
по-прежнему лежит одним куском.

Книга: [Mark Bernstein](http://www.markbernstein.org/) &#x2013; [The Tinderbox Way](http://www.eastgate.com/Tinderbox/TinderboxWay.html)

Сайт разработчика: [Mark Bernstein](http://www.markbernstein.org/)

Wiki: [Tinderbox](https://en.wikipedia.org/wiki/Tinderbox_%28application_software%29)

Release dates: ![img](//www.markbernstein.org/elements/Releases.jpg)

## (2003) Joshua Schachter — Del.icio.us<a id="sec-7-15" name="sec-7-15"></a>

Старая заметка про [delicious](https://delicious.com):

> Про отношения с делишесом. Плохие у меня с делишесом
> отношения. Естественный подход мне не нравится. Точнее он у
> меня изначально вызвал какое-то непонимание. Поэтому изначально
> я пользовался противоестественным способом. Пытался добавлять
> избытычные метаданные. Сделал подобие онтологии. Но проблема
> этого подхода в том, что дальше с данными сделать ничего
> нельзя. Язык запросов лучше даже на френдфиде.
>
> Есть другая сторона. Почему фрф лучше для показывания
> ссылок. Сохранение ссылки очень мало кто сопровождает тем почему
> эта ссылка привлекла внимание. Никто не пишет эту самую
> пресловутую тысячу знаков. Это долго и никому не
> инетересно. Сохранение ссылки – это тоже самое рассказывание
> истории. Потому что без истории ссылки никому не нужна. Этих
> ссылок вокруг слишком много, чтобы во все тыкать и самому
> разбираться что там к чему. Социальность делишеса проявляется
> только в одном случае – когда люди начинают искать популярные
> ссылки по какому-то тегу.
>
> Компенсировать отсутствие обсуждения заправлением делишеса во
> френдфид тоже плохо. Потому что если исходить из того, что это все
> ссылки "на потом", то соотношение сигнал/шум становится слишком
> низким. Каждый сохраняет в день по несколько ссылок умножить на
> количество френдов – получается жуткий мусор. Поэтому ссылки нужно
> обсуждать там, где они лежат.
>
> Одно время я очень перся от делишеса, но сейчас это прошло. Тогда
> мне хотелось, чтобы так можно было работать с файлами на харде. Но
> если из метаданных нельзя ничего выжать, то на фиг они нужны?
>
> У делишеса есть проблема интерфейса – сохранять слишком долго. В
> результате на смену ему пришел Read It Later. Пост сохраняется
> одним нажатием галочки. Получается обычный линейный список. То,
> что прошло испытание временем переносится в делишес. Или про это
> рассказывается история во френфиде. Лишнее удаляется одним
> кликом. То что там нет тегов – это отдельная тема. Мне кажется,
> что ключевые слова можно вытаскивать из текста
> автоматом. Используя API того же делишеса или гугла. Или тупо
> смотреть по частоте.
>
> Получается, что делишес – это медленные коммуникации. Медленные
> именно из-за интерфейса, а не по сути. Из этого вытекает очевидное
> в принципе заключение, что пропускная способность интерфейса
> определяет суть сервиса. Если сделать медленный интерфейс для
> чата, то это будет уже форум. Условно говоря. Если сделать быстрый
> интерфейс для форума, то получится френдфид. Опять же очень
> условно.

## (2003) Org-mode<a id="sec-7-16" name="sec-7-16"></a>

Outliner для emacs. Выяснилось, что пока нет хорошего инструмента,
которому можно доверять, вполне можно жить с помощью текстовых
файлов и git.

<http://orgmode.org/>

## (2004) W3C — RDF / RDFS / OWL<a id="sec-7-17" name="sec-7-17"></a>

## (2007) DBpedia<a id="sec-7-18" name="sec-7-18"></a>

Вытаскивает структурированные данные из википедии, конвертит их в
RDF, позволяет делать запросы на SPARQL.

Wiki: [DBpedia](https://en.wikipedia.org/wiki/DBpedia)

## (2007) Scrivener<a id="sec-7-19" name="sec-7-19"></a>

Инструмент для написания текстов. Есть текстовый редактор и
контроль версий. Есть хранилище связанных файлов и их отображение в
виде доски. Какие-то инструменты для рефакторинга в духе
"переименовать персонажа".

Надо еще в нем покопаться, но пока ощущение что в целом он про текст
как проект.

<http://www.literatureandlatte.com/scrivener.html>

## (2008) Evernote<a id="sec-7-20" name="sec-7-20"></a>

Подкаст с Пачиковым: [Рунетология 45](http://runetologia.podfm.ru/96/)

Wiki: [Evernote](https://en.wikipedia.org/wiki/Evernote)

## (2009) Fluidinfo<a id="sec-7-21" name="sec-7-21"></a>

У них очень прикольный [блог](http://blogs.fluidinfo.com/), если читать его с начала, а не с конца.

<http://fluidinfo.com>

## (2013) Ginko<a id="sec-7-22" name="sec-7-22"></a>

Хороший. Умеет делать презентации и возвращать текст в виде
json. Интересен в первую очередь интерфейсом.

<https://gingkoapp.com>

## Calibre<a id="sec-7-23" name="sec-7-23"></a>

Reference-mode в читалке. Решение проблемы идентификации для
электронных книг.

<https://calibre-ebook.com/>

## Smallest Federated Wiki<a id="sec-7-24" name="sec-7-24"></a>

Создатель первой вики, [Ward Cunningham](https://en.wikipedia.org/wiki/Ward_Cunningham), делает федеративную
вики. Страницы можно форкать и поддерживать локально свою версию.

<http://fed.wiki.org>

## Chandler<a id="sec-7-25" name="sec-7-25"></a>

Wiki: [Chandler](https://en.wikipedia.org/wiki/Chandler_%28software%29)

## CommonTag<a id="sec-7-26" name="sec-7-26"></a>

Теги на основе заголовков статей в википедии. Позволяют получить
для тега хорошо прописанную семантику, в том числе на разных
языках. Какая-то инкарнация этой идеи вроде используется в facebook
для отмечания интересов пользователя.

<http://microformats.org/wiki/CommonTag>

## Friendfeed<a id="sec-7-27" name="sec-7-27"></a>

Помимо всего прочего умел собирать данных из разных источников в
одну ленту.

## Locker<a id="sec-7-28" name="sec-7-28"></a>

Метасервис по собиранию данных из разных веб-сервисов в единую
ленту.

## Singly<a id="sec-7-29" name="sec-7-29"></a>

Метасервис по собиранию данных из разных веб-сервисов в единую
ленту. Singly ориентирован не только на собирание, но и на
предоставление к собранному API для различных манипуляций и
визуализации.

> Singly was founded by Jeremie Miller, creator of XMPP, Jason Cavnar
> and Simon Murtha-Smith. Matt Zimmerman, former CTO of Ubuntu,
> joined Singly and was the CTO.

2013-08-22 &#x2013; поглощен компанией [appcelerator](http://appcelerator.com/).

## NEPOMUK<a id="sec-7-30" name="sec-7-30"></a>

<https://en.wikipedia.org/wiki/NEPOMUK_%28framework%29>

## TiddlyWiki<a id="sec-7-31" name="sec-7-31"></a>

<http://tiddlywiki.com/>

# Ссылки<a id="sec-8" name="sec-8"></a>

<http://infotoday.com/> &#x2013; новости

<http://booksblog.infotoday.com/> &#x2013; книги

Каталог статей на сайте Брета Виктора: Engelbart, Bush, Alan Key и
другие - <http://worrydream.com/refs/>.

## Учебные заведения<a id="sec-8-1" name="sec-8-1"></a>

[UC Berkeley School of Information](http://www.ischool.berkeley.edu/)
-   [INFO202: Information Organization and Retrieval (Fall 2014)](https://bcourses.berkeley.edu/courses/1247347/assignments/syllabus)

[University of Washington Information School](https://ischool.uw.edu/)
-   [Keeping Found Things Found](http://kftf.ischool.washington.edu/)

## Термины<a id="sec-8-2" name="sec-8-2"></a>

-   [Personal information manager](https://en.wikipedia.org/wiki/Personal_information_manager)
-   [Semantic Web](https://en.wikipedia.org/wiki/Semantic_Web)
-   [Personal knowledge base](https://en.wikipedia.org/wiki/Personal_knowledge_base)
-   [Information science](https://en.wikipedia.org/wiki/Information_science)
-   [Faceted classification](https://en.wikipedia.org/wiki/Faceted_classification)
-   [Metadata](https://en.wikipedia.org/wiki/Metadata)
-   [Entity–attribute–value model](https://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model)
-   [Adaptive hypermedia](https://en.wikipedia.org/wiki/Adaptive_hypermedia)
-   [Hypertext](https://en.wikipedia.org/wiki/Hypertext)
-   [Semantic desktop](https://en.wikipedia.org/wiki/Semantic_desktop)
-   [Parallel text](https://en.wikipedia.org/wiki/Parallel_text)
-   [Transclusion](https://en.wikipedia.org/wiki/Transclusion)
-   [Graph database](https://en.wikipedia.org/wiki/Graph_database)
-   [Universally unique identifier (UUID)](https://en.wikipedia.org/wiki/Universally_unique_identifier)
-   [URI](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier) / [URL](https://en.wikipedia.org/wiki/Uniform_Resource_Locator) / [URN](https://en.wikipedia.org/wiki/Uniform_Resource_Name)
-   [Dublin Core](https://en.wikipedia.org/wiki/Dublin_Core)

## Люди<a id="sec-8-3" name="sec-8-3"></a>

-   [Douglas Engelbart](https://en.wikipedia.org/wiki/Douglas_Engelbart)
-   [Vannevar Bush](https://en.wikipedia.org/wiki/Vannevar_Bush)
-   [Andries van Dam](https://en.wikipedia.org/wiki/Andries_van_Dam)
-   [Ted Nelson](https://en.wikipedia.org/wiki/Ted_Nelson)

## Книги<a id="sec-8-4" name="sec-8-4"></a>

История:
-   [Memory Machines: The Evolution of Hypertext](http://www.anthempress.com/memory-machines) (Anthem Press)

Техническое:
-   A Semantic Web Primer (MIT Press)
-   Semantic Web for the Working Ontologist (Morgan-Kaufman)
-   Learning SPARQL (O'Reilly)
-   Graph Databases (O'Reilly)

Методологическое:
-   Keeping Found Things Found (Morgan-Kaufman)
-   The Discipline of Organizing (MIT Press)

Художественное:
-   Игра в бисер (Герман Гессе)

## Ассоциации<a id="sec-8-5" name="sec-8-5"></a>

-   [Association for Information Science and Technology](https://www.asist.org/)

## urbansheep<a id="sec-8-6" name="sec-8-6"></a>

### Pinboard<a id="sec-8-6-1" name="sec-8-6-1"></a>

-   [KM](https://pinboard.in/u:urbansheep/t:km/) / [knowledgemanagement](https://pinboard.in/u:urbansheep/t:knowledgemanagement/)
-   [infoorg](https://pinboard.in/u:urbansheep/t:infoorg/)
-   [hypertext](https://pinboard.in/u:urbansheep/t:hypertext/)
-   [semanticweb](https://pinboard.in/u:urbansheep/t:semanticweb/)
-   [classification](https://pinboard.in/u:urbansheep/t:classification/)
-   [metadata](https://pinboard.in/u:urbansheep/t:metadata/)

### FriendFeed<a id="sec-8-6-2" name="sec-8-6-2"></a>

-   [инфоорг](http://urbansheep.com/friendfeed/urbansheep/lists/hashtags/infoorg.html)
-   [свой небольшой интернет](http://urbansheep.com/friendfeed/urbansheep/lists/hashtags/svoy_nebolshoy_internet.html)
-   [цифровая история](http://urbansheep.com/friendfeed/urbansheep/lists/hashtags/tsifrovaya_istoriya.html)
-   [архивисты](http://urbansheep.com/friendfeed/urbansheep/lists/hashtags/arhivisty.html)

### LiveJournal<a id="sec-8-6-3" name="sec-8-6-3"></a>

-   [info organization](https://urbansheep.livejournal.com/tag/info organization)
-   [classification](https://urbansheep.livejornal.com/tag/classification)
-   [memory management](https://urbansheep.livejournal.com/tag/memory_management)
-   [knowledge management](https://urbansheep.livejournal.com/tag/knowledge_management)
-   [hypertext](https://urbansheep.livejornal.com/tag/hypertext)

## Конференции<a id="sec-8-7" name="sec-8-7"></a>

-   [Personal Digital Archiving Conference](https://archive.org/details/PDA2015)
